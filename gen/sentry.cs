// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace sentry
{
    /// <summary>Type of a sentry value.</summary>
    public enum SentryValueTypeT : uint
    {
        SENTRY_VALUE_TYPE_NULL = 0,
        SENTRY_VALUE_TYPE_BOOL = 1,
        SENTRY_VALUE_TYPE_INT32 = 2,
        SENTRY_VALUE_TYPE_DOUBLE = 3,
        SENTRY_VALUE_TYPE_STRING = 4,
        SENTRY_VALUE_TYPE_LIST = 5,
        SENTRY_VALUE_TYPE_OBJECT = 6
    }

    /// <summary>Sentry levels for events and breadcrumbs.</summary>
    public enum SentryLevelE
    {
        SENTRY_LEVEL_DEBUG = -1,
        SENTRY_LEVEL_INFO = 0,
        SENTRY_LEVEL_WARNING = 1,
        SENTRY_LEVEL_ERROR = 2,
        SENTRY_LEVEL_FATAL = 3
    }

    /// <summary>The state of user consent.</summary>
    public enum SentryUserConsentT
    {
        SENTRY_USER_CONSENT_UNKNOWN = -1,
        SENTRY_USER_CONSENT_GIVEN = 1,
        SENTRY_USER_CONSENT_REVOKED = 0
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void SigT(int __0);

    /// <summary>Type of a sentry value.</summary>
    /// <summary>Sentry levels for events and breadcrumbs.</summary>
    /// <summary>
    /// <para>This represents the OS dependent user context in the case of a crash, and can</para>
    /// <para>be used to manually capture a crash.</para>
    /// </summary>
    /// <summary>A UUID</summary>
    /// <summary>The state of user consent.</summary>
    /// <summary>Type of the `before_send` callback.</summary>
    /// <remarks>
    /// <para>The callback takes ownership of the `event`, and should usually return that</para>
    /// <para>same event. In case the event should be discarded, the callback needs to</para>
    /// <para>call `sentry_value_decref` on the provided event, and return a</para>
    /// <para>`sentry_value_new_null()` instead.</para>
    /// <para>This function may be invoked inside of a signal handler and must be safe for</para>
    /// <para>that purpose, see https://man7.org/linux/man-pages/man7/signal-safety.7.html.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::sentry.SentryValueU.__Internal SentryEventFunctionT(global::sentry.SentryValueU.__Internal @event, __IntPtr hint, __IntPtr closure);

    public unsafe partial struct MbstateT
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed sbyte __mbstate8[128];

            [FieldOffset(0)]
            internal long _mbstateL;
        }

        private MbstateT.__Internal __instance;
        internal MbstateT.__Internal __Instance { get { return __instance; } }

        internal static MbstateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MbstateT(native.ToPointer(), skipVTables);
        }

        internal static MbstateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MbstateT(native, skipVTables);
        }

        private MbstateT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private MbstateT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::sentry.MbstateT.__Internal*) native;
        }

        public sbyte[] Mbstate8
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.__mbstate8)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 128);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.__mbstate8)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 128; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public long MbstateL
        {
            get
            {
                return __instance._mbstateL;
            }

            set
            {
                __instance._mbstateL = value;
            }
        }
    }

    /// <summary>A Sentry Envelope.</summary>
    /// <remarks>
    /// <para>The Envelope is an abstract type which represents a payload being sent to</para>
    /// <para>sentry. It can contain one or more items, typically an Event.</para>
    /// <para>See https://develop.sentry.dev/sdk/envelopes/</para>
    /// </remarks>
    public unsafe partial class SentryEnvelopeS
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryEnvelopeS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryEnvelopeS>();

        protected bool __ownsNativeInstance;

        internal static SentryEnvelopeS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryEnvelopeS(native.ToPointer(), skipVTables);
        }

        internal static SentryEnvelopeS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryEnvelopeS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryEnvelopeS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryEnvelopeS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryEnvelopeS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryEnvelopeS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>The Sentry Client Options.</summary>
    /// <remarks>See https://docs.sentry.io/error-reporting/configuration/</remarks>
    public unsafe partial class SentryOptionsS
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryOptionsS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryOptionsS>();

        protected bool __ownsNativeInstance;

        internal static SentryOptionsS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryOptionsS(native.ToPointer(), skipVTables);
        }

        internal static SentryOptionsS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryOptionsS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryOptionsS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryOptionsS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryOptionsS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryOptionsS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>This represents an interface for user-defined transports.</summary>
    /// <remarks>
    /// <para>Transports are responsible for sending envelopes to sentry and are the last</para>
    /// <para>step in the event pipeline.</para>
    /// <para>Envelopes will be submitted to the transport in a _fire and forget_ fashion,</para>
    /// <para>and the transport must send those envelopes _in order_.</para>
    /// <para>A transport has the following hooks, all of which</para>
    /// <para>take the user provided `state` as last parameter. The transport state needs</para>
    /// <para>to be set with `sentry_transport_set_state` and typically holds handles and</para>
    /// <para>other information that can be reused across requests.</para>
    /// <para>* `send_func`: This function will take ownership of an envelope, and is</para>
    /// <para>responsible for freeing it via `sentry_envelope_free`.</para>
    /// <para>* `startup_func`: This hook will be called by sentry inside of `sentry_init`</para>
    /// <para>and instructs the transport to initialize itself. Failures will bubble up</para>
    /// <para>to `sentry_init`.</para>
    /// <para>* `shutdown_func`: Instructs the transport to flush its queue and shut down.</para>
    /// <para>This hook receives a millisecond-resolution `timeout` parameter and should</para>
    /// <para>return `true` when the transport was flushed and shut down successfully.</para>
    /// <para>In case of `false`, sentry will log an error, but continue with freeing the</para>
    /// <para>transport.</para>
    /// <para>* `free_func`: Frees the transports `state`. This hook might be called even</para>
    /// <para>though `shudown_func` returned `false` previously.</para>
    /// <para>The transport interface might be extended in the future with hooks to flush</para>
    /// <para>its internal queue without shutting down, and to dump its internal queue to</para>
    /// <para>disk in case of a hard crash.</para>
    /// </remarks>
    public unsafe partial class SentryTransportS
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryTransportS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryTransportS>();

        protected bool __ownsNativeInstance;

        internal static SentryTransportS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryTransportS(native.ToPointer(), skipVTables);
        }

        internal static SentryTransportS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryTransportS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryTransportS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryTransportS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryTransportS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryTransportS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class DarwinPthreadHandlerRec : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal __IntPtr __routine;
            internal __IntPtr __arg;
            internal __IntPtr __next;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinPthreadHandlerRec> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinPthreadHandlerRec>();

        protected bool __ownsNativeInstance;

        internal static DarwinPthreadHandlerRec __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinPthreadHandlerRec(native.ToPointer(), skipVTables);
        }

        internal static DarwinPthreadHandlerRec __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinPthreadHandlerRec)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinPthreadHandlerRec __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinPthreadHandlerRec(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinPthreadHandlerRec(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinPthreadHandlerRec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.Delegates.Action___IntPtr Routine
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->__routine;
                return __ptr0 == IntPtr.Zero? null : (global::sentry.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::sentry.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->__routine = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr Arg
        {
            get
            {
                return ((__Internal*)__Instance)->__arg;
            }

            set
            {
                ((__Internal*)__Instance)->__arg = (__IntPtr) value;
            }
        }

        public global::sentry.DarwinPthreadHandlerRec Next
        {
            get
            {
                var __result0 = global::sentry.DarwinPthreadHandlerRec.__GetOrCreateInstance(((__Internal*)__Instance)->__next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->__next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class OpaquePthreadAttrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal int __sig;
            internal fixed sbyte __opaque[36];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadAttrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadAttrT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadAttrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadAttrT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadAttrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadAttrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadAttrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadAttrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadAttrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadAttrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 36);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 36; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class OpaquePthreadCondT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal int __sig;
            internal fixed sbyte __opaque[24];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadCondT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadCondT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadCondT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadCondT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadCondT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadCondT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadCondT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadCondT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadCondT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadCondT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 24);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 24; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class OpaquePthreadCondattrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int __sig;
            internal fixed sbyte __opaque[4];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadCondattrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadCondattrT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadCondattrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadCondattrT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadCondattrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadCondattrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadCondattrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadCondattrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadCondattrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadCondattrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class OpaquePthreadMutexT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 44)]
        public partial struct __Internal
        {
            internal int __sig;
            internal fixed sbyte __opaque[40];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadMutexT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadMutexT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadMutexT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadMutexT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadMutexT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadMutexT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadMutexT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadMutexT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadMutexT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadMutexT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 40);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 40; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class OpaquePthreadMutexattrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int __sig;
            internal fixed sbyte __opaque[8];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadMutexattrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadMutexattrT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadMutexattrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadMutexattrT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadMutexattrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadMutexattrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadMutexattrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadMutexattrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadMutexattrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadMutexattrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class OpaquePthreadOnceT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int __sig;
            internal fixed sbyte __opaque[4];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadOnceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadOnceT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadOnceT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadOnceT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadOnceT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadOnceT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadOnceT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadOnceT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadOnceT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadOnceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class OpaquePthreadRwlockT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 128)]
        public partial struct __Internal
        {
            internal int __sig;
            internal fixed sbyte __opaque[124];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadRwlockT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadRwlockT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadRwlockT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadRwlockT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadRwlockT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadRwlockT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadRwlockT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadRwlockT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadRwlockT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadRwlockT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 124);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 124; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class OpaquePthreadRwlockattrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int __sig;
            internal fixed sbyte __opaque[12];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadRwlockattrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadRwlockattrT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadRwlockattrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadRwlockattrT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadRwlockattrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadRwlockattrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadRwlockattrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadRwlockattrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadRwlockattrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadRwlockattrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 12);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class OpaquePthreadT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4096)]
        public partial struct __Internal
        {
            internal int __sig;
            internal __IntPtr __cleanup_stack;
            internal fixed sbyte __opaque[4088];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.OpaquePthreadT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public global::sentry.DarwinPthreadHandlerRec CleanupStack
        {
            get
            {
                var __result0 = global::sentry.DarwinPthreadHandlerRec.__GetOrCreateInstance(((__Internal*)__Instance)->__cleanup_stack, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->__cleanup_stack = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 4088);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4088; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class DarwinI386ThreadState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal uint __eax;
            internal uint __ebx;
            internal uint __ecx;
            internal uint __edx;
            internal uint __edi;
            internal uint __esi;
            internal uint __ebp;
            internal uint __esp;
            internal uint __ss;
            internal uint __eflags;
            internal uint __eip;
            internal uint __cs;
            internal uint __ds;
            internal uint __es;
            internal uint __fs;
            internal uint __gs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386ThreadState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386ThreadState>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386ThreadState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386ThreadState(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386ThreadState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386ThreadState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386ThreadState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386ThreadState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386ThreadState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386ThreadState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Eax
        {
            get
            {
                return ((__Internal*)__Instance)->__eax;
            }

            set
            {
                ((__Internal*)__Instance)->__eax = value;
            }
        }

        public uint Ebx
        {
            get
            {
                return ((__Internal*)__Instance)->__ebx;
            }

            set
            {
                ((__Internal*)__Instance)->__ebx = value;
            }
        }

        public uint Ecx
        {
            get
            {
                return ((__Internal*)__Instance)->__ecx;
            }

            set
            {
                ((__Internal*)__Instance)->__ecx = value;
            }
        }

        public uint Edx
        {
            get
            {
                return ((__Internal*)__Instance)->__edx;
            }

            set
            {
                ((__Internal*)__Instance)->__edx = value;
            }
        }

        public uint Edi
        {
            get
            {
                return ((__Internal*)__Instance)->__edi;
            }

            set
            {
                ((__Internal*)__Instance)->__edi = value;
            }
        }

        public uint Esi
        {
            get
            {
                return ((__Internal*)__Instance)->__esi;
            }

            set
            {
                ((__Internal*)__Instance)->__esi = value;
            }
        }

        public uint Ebp
        {
            get
            {
                return ((__Internal*)__Instance)->__ebp;
            }

            set
            {
                ((__Internal*)__Instance)->__ebp = value;
            }
        }

        public uint Esp
        {
            get
            {
                return ((__Internal*)__Instance)->__esp;
            }

            set
            {
                ((__Internal*)__Instance)->__esp = value;
            }
        }

        public uint Ss
        {
            get
            {
                return ((__Internal*)__Instance)->__ss;
            }

            set
            {
                ((__Internal*)__Instance)->__ss = value;
            }
        }

        public uint Eflags
        {
            get
            {
                return ((__Internal*)__Instance)->__eflags;
            }

            set
            {
                ((__Internal*)__Instance)->__eflags = value;
            }
        }

        public uint Eip
        {
            get
            {
                return ((__Internal*)__Instance)->__eip;
            }

            set
            {
                ((__Internal*)__Instance)->__eip = value;
            }
        }

        public uint Cs
        {
            get
            {
                return ((__Internal*)__Instance)->__cs;
            }

            set
            {
                ((__Internal*)__Instance)->__cs = value;
            }
        }

        public uint Ds
        {
            get
            {
                return ((__Internal*)__Instance)->__ds;
            }

            set
            {
                ((__Internal*)__Instance)->__ds = value;
            }
        }

        public uint Es
        {
            get
            {
                return ((__Internal*)__Instance)->__es;
            }

            set
            {
                ((__Internal*)__Instance)->__es = value;
            }
        }

        public uint Fs
        {
            get
            {
                return ((__Internal*)__Instance)->__fs;
            }

            set
            {
                ((__Internal*)__Instance)->__fs = value;
            }
        }

        public uint Gs
        {
            get
            {
                return ((__Internal*)__Instance)->__gs;
            }

            set
            {
                ((__Internal*)__Instance)->__gs = value;
            }
        }
    }

    public unsafe partial class DarwinFpControl : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort __invalid;

            [FieldOffset(0)]
            internal ushort __denorm;

            [FieldOffset(0)]
            internal ushort __zdiv;

            [FieldOffset(0)]
            internal ushort __ovrfl;

            [FieldOffset(0)]
            internal ushort __undfl;

            [FieldOffset(0)]
            internal ushort __precis;

            [FieldOffset(0)]
            internal ushort _0;

            [FieldOffset(1)]
            internal ushort __pc;

            [FieldOffset(1)]
            internal ushort __rc;

            [FieldOffset(1)]
            internal ushort _1;

            [FieldOffset(1)]
            internal ushort _2;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinFpControl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinFpControl>();

        protected bool __ownsNativeInstance;

        internal static DarwinFpControl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinFpControl(native.ToPointer(), skipVTables);
        }

        internal static DarwinFpControl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinFpControl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinFpControl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinFpControl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinFpControl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinFpControl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Invalid
        {
            get
            {
                return ((__Internal*)__Instance)->__invalid;
            }

            set
            {
                ((__Internal*)__Instance)->__invalid = value;
            }
        }

        public ushort Denorm
        {
            get
            {
                return ((__Internal*)__Instance)->__denorm;
            }

            set
            {
                ((__Internal*)__Instance)->__denorm = value;
            }
        }

        public ushort Zdiv
        {
            get
            {
                return ((__Internal*)__Instance)->__zdiv;
            }

            set
            {
                ((__Internal*)__Instance)->__zdiv = value;
            }
        }

        public ushort Ovrfl
        {
            get
            {
                return ((__Internal*)__Instance)->__ovrfl;
            }

            set
            {
                ((__Internal*)__Instance)->__ovrfl = value;
            }
        }

        public ushort Undfl
        {
            get
            {
                return ((__Internal*)__Instance)->__undfl;
            }

            set
            {
                ((__Internal*)__Instance)->__undfl = value;
            }
        }

        public ushort Precis
        {
            get
            {
                return ((__Internal*)__Instance)->__precis;
            }

            set
            {
                ((__Internal*)__Instance)->__precis = value;
            }
        }

        public ushort _0
        {
            get
            {
                return ((__Internal*)__Instance)->_0;
            }

            set
            {
                ((__Internal*)__Instance)->_0 = value;
            }
        }

        public ushort Pc
        {
            get
            {
                return ((__Internal*)__Instance)->__pc;
            }

            set
            {
                ((__Internal*)__Instance)->__pc = value;
            }
        }

        public ushort Rc
        {
            get
            {
                return ((__Internal*)__Instance)->__rc;
            }

            set
            {
                ((__Internal*)__Instance)->__rc = value;
            }
        }
    }

    public unsafe partial class DarwinFpStatus : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort __invalid;

            [FieldOffset(0)]
            internal ushort __denorm;

            [FieldOffset(0)]
            internal ushort __zdiv;

            [FieldOffset(0)]
            internal ushort __ovrfl;

            [FieldOffset(0)]
            internal ushort __undfl;

            [FieldOffset(0)]
            internal ushort __precis;

            [FieldOffset(0)]
            internal ushort __stkflt;

            [FieldOffset(0)]
            internal ushort __errsumm;

            [FieldOffset(1)]
            internal ushort __c0;

            [FieldOffset(1)]
            internal ushort __c1;

            [FieldOffset(1)]
            internal ushort __c2;

            [FieldOffset(1)]
            internal ushort __tos;

            [FieldOffset(1)]
            internal ushort __c3;

            [FieldOffset(1)]
            internal ushort __busy;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinFpStatus> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinFpStatus>();

        protected bool __ownsNativeInstance;

        internal static DarwinFpStatus __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinFpStatus(native.ToPointer(), skipVTables);
        }

        internal static DarwinFpStatus __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinFpStatus)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinFpStatus __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinFpStatus(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinFpStatus(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinFpStatus(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Invalid
        {
            get
            {
                return ((__Internal*)__Instance)->__invalid;
            }

            set
            {
                ((__Internal*)__Instance)->__invalid = value;
            }
        }

        public ushort Denorm
        {
            get
            {
                return ((__Internal*)__Instance)->__denorm;
            }

            set
            {
                ((__Internal*)__Instance)->__denorm = value;
            }
        }

        public ushort Zdiv
        {
            get
            {
                return ((__Internal*)__Instance)->__zdiv;
            }

            set
            {
                ((__Internal*)__Instance)->__zdiv = value;
            }
        }

        public ushort Ovrfl
        {
            get
            {
                return ((__Internal*)__Instance)->__ovrfl;
            }

            set
            {
                ((__Internal*)__Instance)->__ovrfl = value;
            }
        }

        public ushort Undfl
        {
            get
            {
                return ((__Internal*)__Instance)->__undfl;
            }

            set
            {
                ((__Internal*)__Instance)->__undfl = value;
            }
        }

        public ushort Precis
        {
            get
            {
                return ((__Internal*)__Instance)->__precis;
            }

            set
            {
                ((__Internal*)__Instance)->__precis = value;
            }
        }

        public ushort Stkflt
        {
            get
            {
                return ((__Internal*)__Instance)->__stkflt;
            }

            set
            {
                ((__Internal*)__Instance)->__stkflt = value;
            }
        }

        public ushort Errsumm
        {
            get
            {
                return ((__Internal*)__Instance)->__errsumm;
            }

            set
            {
                ((__Internal*)__Instance)->__errsumm = value;
            }
        }

        public ushort C0
        {
            get
            {
                return ((__Internal*)__Instance)->__c0;
            }

            set
            {
                ((__Internal*)__Instance)->__c0 = value;
            }
        }

        public ushort C1
        {
            get
            {
                return ((__Internal*)__Instance)->__c1;
            }

            set
            {
                ((__Internal*)__Instance)->__c1 = value;
            }
        }

        public ushort C2
        {
            get
            {
                return ((__Internal*)__Instance)->__c2;
            }

            set
            {
                ((__Internal*)__Instance)->__c2 = value;
            }
        }

        public ushort Tos
        {
            get
            {
                return ((__Internal*)__Instance)->__tos;
            }

            set
            {
                ((__Internal*)__Instance)->__tos = value;
            }
        }

        public ushort C3
        {
            get
            {
                return ((__Internal*)__Instance)->__c3;
            }

            set
            {
                ((__Internal*)__Instance)->__c3 = value;
            }
        }

        public ushort Busy
        {
            get
            {
                return ((__Internal*)__Instance)->__busy;
            }

            set
            {
                ((__Internal*)__Instance)->__busy = value;
            }
        }
    }

    public unsafe partial class DarwinMmstReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed sbyte __mmst_reg[10];
            internal fixed sbyte __mmst_rsrv[6];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMmstReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMmstReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinMmstReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMmstReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinMmstReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMmstReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMmstReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMmstReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMmstReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMmstReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] MmstReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__mmst_reg, 10);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 10; i++)
                        ((__Internal*)__Instance)->__mmst_reg[i] = value[i];
                }
            }
        }

        public sbyte[] MmstRsrv
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__mmst_rsrv, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->__mmst_rsrv[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class DarwinXmmReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed sbyte __xmm_reg[16];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinXmmReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinXmmReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinXmmReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinXmmReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinXmmReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinXmmReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinXmmReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinXmmReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinXmmReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinXmmReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] XmmReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__xmm_reg, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->__xmm_reg[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class DarwinYmmReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal fixed sbyte __ymm_reg[32];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinYmmReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinYmmReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinYmmReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinYmmReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinYmmReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinYmmReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinYmmReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinYmmReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinYmmReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinYmmReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] YmmReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__ymm_reg, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->__ymm_reg[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class DarwinZmmReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal fixed sbyte __zmm_reg[64];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinZmmReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinZmmReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinZmmReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinZmmReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinZmmReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinZmmReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinZmmReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinZmmReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinZmmReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinZmmReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] ZmmReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__zmm_reg, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__zmm_reg[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class DarwinOpmaskReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal fixed sbyte __opmask_reg[8];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinOpmaskReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinOpmaskReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinOpmaskReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinOpmaskReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinOpmaskReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinOpmaskReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinOpmaskReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinOpmaskReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinOpmaskReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinOpmaskReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] OpmaskReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opmask_reg, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->__opmask_reg[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class DarwinI386FloatState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 524)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::sentry.DarwinFpControl.__Internal __fpu_fcw;
            internal global::sentry.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm7;
            internal fixed sbyte __fpu_rsrv4[224];
            internal int __fpu_reserved1;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386FloatState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386FloatState>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386FloatState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386FloatState(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386FloatState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386FloatState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386FloatState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386FloatState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386FloatState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386FloatState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinFpControl FpuFcw
        {
            get
            {
                return global::sentry.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::sentry.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::sentry.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::sentry.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 224);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 224; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }
    }

    public unsafe partial class DarwinI386AvxState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 716)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::sentry.DarwinFpControl.__Internal __fpu_fcw;
            internal global::sentry.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm7;
            internal fixed sbyte __fpu_rsrv4[224];
            internal int __fpu_reserved1;
            internal fixed sbyte __avx_reserved1[64];
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh7;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386AvxState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386AvxState>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386AvxState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386AvxState(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386AvxState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386AvxState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386AvxState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386AvxState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386AvxState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386AvxState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinFpControl FpuFcw
        {
            get
            {
                return global::sentry.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::sentry.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::sentry.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::sentry.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 224);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 224; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }

        public sbyte[] AvxReserved1
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__avx_reserved1, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__avx_reserved1[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinI386Avx512State : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1036)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::sentry.DarwinFpControl.__Internal __fpu_fcw;
            internal global::sentry.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm7;
            internal fixed sbyte __fpu_rsrv4[224];
            internal int __fpu_reserved1;
            internal fixed sbyte __avx_reserved1[64];
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh7;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k0;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k1;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k2;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k3;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k4;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k5;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k6;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k7;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh0;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh1;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh2;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh3;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh4;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh5;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh6;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh7;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386Avx512State> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386Avx512State>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386Avx512State __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386Avx512State(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386Avx512State __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386Avx512State)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386Avx512State __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386Avx512State(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386Avx512State(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386Avx512State(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinFpControl FpuFcw
        {
            get
            {
                return global::sentry.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::sentry.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::sentry.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::sentry.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 224);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 224; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }

        public sbyte[] AvxReserved1
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__avx_reserved1, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__avx_reserved1[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK0
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k0 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK1
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k1 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK2
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k2 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK3
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k3 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK4
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k4 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK5
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k5 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK6
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k6 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK7
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k7 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh0
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh0 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh1
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh1 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh2
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh2 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh3
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh3 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh4
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh4 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh5
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh5 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh6
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh6 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh7
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh7 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinI386ExceptionState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal ushort __trapno;
            internal ushort __cpu;
            internal uint __err;
            internal uint __faultvaddr;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386ExceptionState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinI386ExceptionState>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386ExceptionState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386ExceptionState(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386ExceptionState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386ExceptionState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386ExceptionState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386ExceptionState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386ExceptionState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386ExceptionState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Trapno
        {
            get
            {
                return ((__Internal*)__Instance)->__trapno;
            }

            set
            {
                ((__Internal*)__Instance)->__trapno = value;
            }
        }

        public ushort Cpu
        {
            get
            {
                return ((__Internal*)__Instance)->__cpu;
            }

            set
            {
                ((__Internal*)__Instance)->__cpu = value;
            }
        }

        public uint Err
        {
            get
            {
                return ((__Internal*)__Instance)->__err;
            }

            set
            {
                ((__Internal*)__Instance)->__err = value;
            }
        }

        public uint Faultvaddr
        {
            get
            {
                return ((__Internal*)__Instance)->__faultvaddr;
            }

            set
            {
                ((__Internal*)__Instance)->__faultvaddr = value;
            }
        }
    }

    public unsafe partial class DarwinX86DebugState32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal uint __dr0;
            internal uint __dr1;
            internal uint __dr2;
            internal uint __dr3;
            internal uint __dr4;
            internal uint __dr5;
            internal uint __dr6;
            internal uint __dr7;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86DebugState32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86DebugState32>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86DebugState32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86DebugState32(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86DebugState32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86DebugState32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86DebugState32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86DebugState32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86DebugState32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86DebugState32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Dr0
        {
            get
            {
                return ((__Internal*)__Instance)->__dr0;
            }

            set
            {
                ((__Internal*)__Instance)->__dr0 = value;
            }
        }

        public uint Dr1
        {
            get
            {
                return ((__Internal*)__Instance)->__dr1;
            }

            set
            {
                ((__Internal*)__Instance)->__dr1 = value;
            }
        }

        public uint Dr2
        {
            get
            {
                return ((__Internal*)__Instance)->__dr2;
            }

            set
            {
                ((__Internal*)__Instance)->__dr2 = value;
            }
        }

        public uint Dr3
        {
            get
            {
                return ((__Internal*)__Instance)->__dr3;
            }

            set
            {
                ((__Internal*)__Instance)->__dr3 = value;
            }
        }

        public uint Dr4
        {
            get
            {
                return ((__Internal*)__Instance)->__dr4;
            }

            set
            {
                ((__Internal*)__Instance)->__dr4 = value;
            }
        }

        public uint Dr5
        {
            get
            {
                return ((__Internal*)__Instance)->__dr5;
            }

            set
            {
                ((__Internal*)__Instance)->__dr5 = value;
            }
        }

        public uint Dr6
        {
            get
            {
                return ((__Internal*)__Instance)->__dr6;
            }

            set
            {
                ((__Internal*)__Instance)->__dr6 = value;
            }
        }

        public uint Dr7
        {
            get
            {
                return ((__Internal*)__Instance)->__dr7;
            }

            set
            {
                ((__Internal*)__Instance)->__dr7 = value;
            }
        }
    }

    public unsafe partial class X86InstructionState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2456)]
        public partial struct __Internal
        {
            internal int __insn_stream_valid_bytes;
            internal int __insn_offset;
            internal int __out_of_synch;
            internal fixed byte __insn_bytes[2380];
            internal fixed byte __insn_cacheline[64];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.X86InstructionState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.X86InstructionState>();

        protected bool __ownsNativeInstance;

        internal static X86InstructionState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new X86InstructionState(native.ToPointer(), skipVTables);
        }

        internal static X86InstructionState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (X86InstructionState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static X86InstructionState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new X86InstructionState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private X86InstructionState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected X86InstructionState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int InsnStreamValidBytes
        {
            get
            {
                return ((__Internal*)__Instance)->__insn_stream_valid_bytes;
            }

            set
            {
                ((__Internal*)__Instance)->__insn_stream_valid_bytes = value;
            }
        }

        public int InsnOffset
        {
            get
            {
                return ((__Internal*)__Instance)->__insn_offset;
            }

            set
            {
                ((__Internal*)__Instance)->__insn_offset = value;
            }
        }

        public int OutOfSynch
        {
            get
            {
                return ((__Internal*)__Instance)->__out_of_synch;
            }

            set
            {
                ((__Internal*)__Instance)->__out_of_synch = value;
            }
        }

        public byte[] InsnBytes
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__insn_bytes, 2380);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2380; i++)
                        ((__Internal*)__Instance)->__insn_bytes[i] = value[i];
                }
            }
        }

        public byte[] InsnCacheline
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__insn_cacheline, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__insn_cacheline[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class LastBranchRecord : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong __from_ip;

            [FieldOffset(8)]
            internal ulong __to_ip;

            [FieldOffset(16)]
            internal uint __mispredict;

            [FieldOffset(16)]
            internal uint __tsx_abort;

            [FieldOffset(16)]
            internal uint __in_tsx;

            [FieldOffset(16)]
            internal uint __cycle_count;

            [FieldOffset(18)]
            internal uint __reserved;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.LastBranchRecord> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.LastBranchRecord>();

        protected bool __ownsNativeInstance;

        internal static LastBranchRecord __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new LastBranchRecord(native.ToPointer(), skipVTables);
        }

        internal static LastBranchRecord __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (LastBranchRecord)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static LastBranchRecord __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LastBranchRecord(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LastBranchRecord(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LastBranchRecord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong FromIp
        {
            get
            {
                return ((__Internal*)__Instance)->__from_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__from_ip = value;
            }
        }

        public ulong ToIp
        {
            get
            {
                return ((__Internal*)__Instance)->__to_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__to_ip = value;
            }
        }

        public uint Mispredict
        {
            get
            {
                return ((__Internal*)__Instance)->__mispredict;
            }

            set
            {
                ((__Internal*)__Instance)->__mispredict = value;
            }
        }

        public uint TsxAbort
        {
            get
            {
                return ((__Internal*)__Instance)->__tsx_abort;
            }

            set
            {
                ((__Internal*)__Instance)->__tsx_abort = value;
            }
        }

        public uint InTsx
        {
            get
            {
                return ((__Internal*)__Instance)->__in_tsx;
            }

            set
            {
                ((__Internal*)__Instance)->__in_tsx = value;
            }
        }

        public uint CycleCount
        {
            get
            {
                return ((__Internal*)__Instance)->__cycle_count;
            }

            set
            {
                ((__Internal*)__Instance)->__cycle_count = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->__reserved;
            }

            set
            {
                ((__Internal*)__Instance)->__reserved = value;
            }
        }
    }

    public unsafe partial class LastBranchState : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 648)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int __lbr_count;

            [FieldOffset(4)]
            internal uint __lbr_supported_tsx;

            [FieldOffset(4)]
            internal uint __lbr_supported_cycle_count;

            [FieldOffset(4)]
            internal uint __reserved;

            [FieldOffset(8)]
            internal fixed byte __lbrs[640];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.LastBranchState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.LastBranchState>();

        protected bool __ownsNativeInstance;

        internal static LastBranchState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new LastBranchState(native.ToPointer(), skipVTables);
        }

        internal static LastBranchState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (LastBranchState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static LastBranchState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LastBranchState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LastBranchState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LastBranchState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LbrCount
        {
            get
            {
                return ((__Internal*)__Instance)->__lbr_count;
            }

            set
            {
                ((__Internal*)__Instance)->__lbr_count = value;
            }
        }

        public uint LbrSupportedTsx
        {
            get
            {
                return ((__Internal*)__Instance)->__lbr_supported_tsx;
            }

            set
            {
                ((__Internal*)__Instance)->__lbr_supported_tsx = value;
            }
        }

        public uint LbrSupportedCycleCount
        {
            get
            {
                return ((__Internal*)__Instance)->__lbr_supported_cycle_count;
            }

            set
            {
                ((__Internal*)__Instance)->__lbr_supported_cycle_count = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->__reserved;
            }

            set
            {
                ((__Internal*)__Instance)->__reserved = value;
            }
        }

        public global::sentry.LastBranchRecord[] Lbrs
        {
            get
            {
                global::sentry.LastBranchRecord[] __value = null;
                if (((__Internal*)__Instance)->__lbrs != null)
                {
                    __value = new global::sentry.LastBranchRecord[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = global::sentry.LastBranchRecord.__CreateInstance(*((global::sentry.LastBranchRecord.__Internal*)&(((__Internal*)__Instance)->__lbrs[i * sizeof(global::sentry.LastBranchRecord.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 32)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 32; i++)
                        *(global::sentry.LastBranchRecord.__Internal*) &((__Internal*)__Instance)->__lbrs[i * sizeof(global::sentry.LastBranchRecord.__Internal)] = *(global::sentry.LastBranchRecord.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class X86PageinState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal int __pagein_error;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.X86PageinState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.X86PageinState>();

        protected bool __ownsNativeInstance;

        internal static X86PageinState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new X86PageinState(native.ToPointer(), skipVTables);
        }

        internal static X86PageinState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (X86PageinState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static X86PageinState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new X86PageinState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private X86PageinState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected X86PageinState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int PageinError
        {
            get
            {
                return ((__Internal*)__Instance)->__pagein_error;
            }

            set
            {
                ((__Internal*)__Instance)->__pagein_error = value;
            }
        }
    }

    public unsafe partial class DarwinX86ThreadState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 168)]
        public partial struct __Internal
        {
            internal ulong __rax;
            internal ulong __rbx;
            internal ulong __rcx;
            internal ulong __rdx;
            internal ulong __rdi;
            internal ulong __rsi;
            internal ulong __rbp;
            internal ulong __rsp;
            internal ulong __r8;
            internal ulong __r9;
            internal ulong __r10;
            internal ulong __r11;
            internal ulong __r12;
            internal ulong __r13;
            internal ulong __r14;
            internal ulong __r15;
            internal ulong __rip;
            internal ulong __rflags;
            internal ulong __cs;
            internal ulong __fs;
            internal ulong __gs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86ThreadState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86ThreadState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86ThreadState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86ThreadState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86ThreadState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86ThreadState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86ThreadState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86ThreadState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86ThreadState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86ThreadState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Rax
        {
            get
            {
                return ((__Internal*)__Instance)->__rax;
            }

            set
            {
                ((__Internal*)__Instance)->__rax = value;
            }
        }

        public ulong Rbx
        {
            get
            {
                return ((__Internal*)__Instance)->__rbx;
            }

            set
            {
                ((__Internal*)__Instance)->__rbx = value;
            }
        }

        public ulong Rcx
        {
            get
            {
                return ((__Internal*)__Instance)->__rcx;
            }

            set
            {
                ((__Internal*)__Instance)->__rcx = value;
            }
        }

        public ulong Rdx
        {
            get
            {
                return ((__Internal*)__Instance)->__rdx;
            }

            set
            {
                ((__Internal*)__Instance)->__rdx = value;
            }
        }

        public ulong Rdi
        {
            get
            {
                return ((__Internal*)__Instance)->__rdi;
            }

            set
            {
                ((__Internal*)__Instance)->__rdi = value;
            }
        }

        public ulong Rsi
        {
            get
            {
                return ((__Internal*)__Instance)->__rsi;
            }

            set
            {
                ((__Internal*)__Instance)->__rsi = value;
            }
        }

        public ulong Rbp
        {
            get
            {
                return ((__Internal*)__Instance)->__rbp;
            }

            set
            {
                ((__Internal*)__Instance)->__rbp = value;
            }
        }

        public ulong Rsp
        {
            get
            {
                return ((__Internal*)__Instance)->__rsp;
            }

            set
            {
                ((__Internal*)__Instance)->__rsp = value;
            }
        }

        public ulong R8
        {
            get
            {
                return ((__Internal*)__Instance)->__r8;
            }

            set
            {
                ((__Internal*)__Instance)->__r8 = value;
            }
        }

        public ulong R9
        {
            get
            {
                return ((__Internal*)__Instance)->__r9;
            }

            set
            {
                ((__Internal*)__Instance)->__r9 = value;
            }
        }

        public ulong R10
        {
            get
            {
                return ((__Internal*)__Instance)->__r10;
            }

            set
            {
                ((__Internal*)__Instance)->__r10 = value;
            }
        }

        public ulong R11
        {
            get
            {
                return ((__Internal*)__Instance)->__r11;
            }

            set
            {
                ((__Internal*)__Instance)->__r11 = value;
            }
        }

        public ulong R12
        {
            get
            {
                return ((__Internal*)__Instance)->__r12;
            }

            set
            {
                ((__Internal*)__Instance)->__r12 = value;
            }
        }

        public ulong R13
        {
            get
            {
                return ((__Internal*)__Instance)->__r13;
            }

            set
            {
                ((__Internal*)__Instance)->__r13 = value;
            }
        }

        public ulong R14
        {
            get
            {
                return ((__Internal*)__Instance)->__r14;
            }

            set
            {
                ((__Internal*)__Instance)->__r14 = value;
            }
        }

        public ulong R15
        {
            get
            {
                return ((__Internal*)__Instance)->__r15;
            }

            set
            {
                ((__Internal*)__Instance)->__r15 = value;
            }
        }

        public ulong Rip
        {
            get
            {
                return ((__Internal*)__Instance)->__rip;
            }

            set
            {
                ((__Internal*)__Instance)->__rip = value;
            }
        }

        public ulong Rflags
        {
            get
            {
                return ((__Internal*)__Instance)->__rflags;
            }

            set
            {
                ((__Internal*)__Instance)->__rflags = value;
            }
        }

        public ulong Cs
        {
            get
            {
                return ((__Internal*)__Instance)->__cs;
            }

            set
            {
                ((__Internal*)__Instance)->__cs = value;
            }
        }

        public ulong Fs
        {
            get
            {
                return ((__Internal*)__Instance)->__fs;
            }

            set
            {
                ((__Internal*)__Instance)->__fs = value;
            }
        }

        public ulong Gs
        {
            get
            {
                return ((__Internal*)__Instance)->__gs;
            }

            set
            {
                ((__Internal*)__Instance)->__gs = value;
            }
        }
    }

    public unsafe partial class DarwinX86ThreadFullState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinX86ThreadState64.__Internal __ss64;
            internal ulong __ds;
            internal ulong __es;
            internal ulong __ss;
            internal ulong __gsbase;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86ThreadFullState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86ThreadFullState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86ThreadFullState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86ThreadFullState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86ThreadFullState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86ThreadFullState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86ThreadFullState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86ThreadFullState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86ThreadFullState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86ThreadFullState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinX86ThreadState64 Ss64
        {
            get
            {
                return global::sentry.DarwinX86ThreadState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss64));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss64 = *(global::sentry.DarwinX86ThreadState64.__Internal*) value.__Instance;
            }
        }

        public ulong Ds
        {
            get
            {
                return ((__Internal*)__Instance)->__ds;
            }

            set
            {
                ((__Internal*)__Instance)->__ds = value;
            }
        }

        public ulong Es
        {
            get
            {
                return ((__Internal*)__Instance)->__es;
            }

            set
            {
                ((__Internal*)__Instance)->__es = value;
            }
        }

        public ulong Ss
        {
            get
            {
                return ((__Internal*)__Instance)->__ss;
            }

            set
            {
                ((__Internal*)__Instance)->__ss = value;
            }
        }

        public ulong Gsbase
        {
            get
            {
                return ((__Internal*)__Instance)->__gsbase;
            }

            set
            {
                ((__Internal*)__Instance)->__gsbase = value;
            }
        }
    }

    public unsafe partial class DarwinX86FloatState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 524)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::sentry.DarwinFpControl.__Internal __fpu_fcw;
            internal global::sentry.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm8;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm9;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm10;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm11;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm12;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm13;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm14;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm15;
            internal fixed sbyte __fpu_rsrv4[96];
            internal int __fpu_reserved1;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86FloatState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86FloatState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86FloatState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86FloatState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86FloatState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86FloatState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86FloatState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86FloatState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86FloatState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86FloatState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinFpControl FpuFcw
        {
            get
            {
                return global::sentry.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::sentry.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::sentry.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::sentry.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm8
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm8 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm9
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm9 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm10
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm10 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm11
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm11 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm12
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm12 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm13
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm13 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm14
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm14 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm15
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm15 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 96);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 96; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }
    }

    public unsafe partial class DarwinX86AvxState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 844)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::sentry.DarwinFpControl.__Internal __fpu_fcw;
            internal global::sentry.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm8;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm9;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm10;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm11;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm12;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm13;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm14;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm15;
            internal fixed sbyte __fpu_rsrv4[96];
            internal int __fpu_reserved1;
            internal fixed sbyte __avx_reserved1[64];
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh8;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh9;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh10;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh11;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh12;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh13;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh14;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh15;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86AvxState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86AvxState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86AvxState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86AvxState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86AvxState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86AvxState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86AvxState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86AvxState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86AvxState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86AvxState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinFpControl FpuFcw
        {
            get
            {
                return global::sentry.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::sentry.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::sentry.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::sentry.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm8
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm8 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm9
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm9 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm10
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm10 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm11
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm11 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm12
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm12 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm13
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm13 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm14
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm14 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm15
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm15 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 96);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 96; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }

        public sbyte[] AvxReserved1
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__avx_reserved1, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__avx_reserved1[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh8
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh8 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh9
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh9 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh10
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh10 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh11
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh11 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh12
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh12 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh13
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh13 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh14
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh14 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh15
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh15 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinX86Avx512State64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2444)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::sentry.DarwinFpControl.__Internal __fpu_fcw;
            internal global::sentry.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::sentry.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm8;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm9;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm10;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm11;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm12;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm13;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm14;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_xmm15;
            internal fixed sbyte __fpu_rsrv4[96];
            internal int __fpu_reserved1;
            internal fixed sbyte __avx_reserved1[64];
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh0;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh1;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh2;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh3;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh4;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh5;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh6;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh7;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh8;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh9;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh10;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh11;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh12;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh13;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh14;
            internal global::sentry.DarwinXmmReg.__Internal __fpu_ymmh15;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k0;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k1;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k2;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k3;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k4;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k5;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k6;
            internal global::sentry.DarwinOpmaskReg.__Internal __fpu_k7;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh0;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh1;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh2;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh3;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh4;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh5;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh6;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh7;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh8;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh9;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh10;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh11;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh12;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh13;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh14;
            internal global::sentry.DarwinYmmReg.__Internal __fpu_zmmh15;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm16;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm17;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm18;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm19;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm20;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm21;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm22;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm23;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm24;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm25;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm26;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm27;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm28;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm29;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm30;
            internal global::sentry.DarwinZmmReg.__Internal __fpu_zmm31;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86Avx512State64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86Avx512State64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86Avx512State64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86Avx512State64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86Avx512State64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86Avx512State64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86Avx512State64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86Avx512State64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86Avx512State64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86Avx512State64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinFpControl FpuFcw
        {
            get
            {
                return global::sentry.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::sentry.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::sentry.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::sentry.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::sentry.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::sentry.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm8
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm8 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm9
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm9 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm10
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm10 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm11
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm11 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm12
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm12 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm13
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm13 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm14
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm14 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuXmm15
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm15 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 96);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 96; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }

        public sbyte[] AvxReserved1
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__avx_reserved1, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__avx_reserved1[i] = value[i];
                }
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh0
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh0 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh1
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh1 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh2
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh2 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh3
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh3 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh4
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh4 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh5
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh5 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh6
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh6 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh7
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh7 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh8
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh8 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh9
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh9 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh10
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh10 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh11
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh11 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh12
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh12 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh13
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh13 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh14
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh14 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinXmmReg FpuYmmh15
        {
            get
            {
                return global::sentry.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh15 = *(global::sentry.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK0
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k0 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK1
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k1 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK2
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k2 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK3
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k3 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK4
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k4 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK5
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k5 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK6
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k6 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinOpmaskReg FpuK7
        {
            get
            {
                return global::sentry.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k7 = *(global::sentry.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh0
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh0 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh1
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh1 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh2
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh2 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh3
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh3 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh4
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh4 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh5
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh5 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh6
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh6 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh7
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh7 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh8
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh8 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh9
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh9 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh10
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh10 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh11
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh11 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh12
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh12 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh13
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh13 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh14
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh14 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinYmmReg FpuZmmh15
        {
            get
            {
                return global::sentry.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh15 = *(global::sentry.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm16
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm16));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm16 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm17
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm17));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm17 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm18
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm18));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm18 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm19
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm19));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm19 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm20
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm20));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm20 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm21
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm21));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm21 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm22
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm22));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm22 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm23
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm23));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm23 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm24
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm24));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm24 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm25
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm25));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm25 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm26
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm26));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm26 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm27
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm27));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm27 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm28
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm28));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm28 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm29
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm29));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm29 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm30
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm30));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm30 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinZmmReg FpuZmm31
        {
            get
            {
                return global::sentry.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm31));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm31 = *(global::sentry.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinX86ExceptionState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort __trapno;
            internal ushort __cpu;
            internal uint __err;
            internal ulong __faultvaddr;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86ExceptionState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86ExceptionState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86ExceptionState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86ExceptionState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86ExceptionState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86ExceptionState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86ExceptionState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86ExceptionState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86ExceptionState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86ExceptionState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Trapno
        {
            get
            {
                return ((__Internal*)__Instance)->__trapno;
            }

            set
            {
                ((__Internal*)__Instance)->__trapno = value;
            }
        }

        public ushort Cpu
        {
            get
            {
                return ((__Internal*)__Instance)->__cpu;
            }

            set
            {
                ((__Internal*)__Instance)->__cpu = value;
            }
        }

        public uint Err
        {
            get
            {
                return ((__Internal*)__Instance)->__err;
            }

            set
            {
                ((__Internal*)__Instance)->__err = value;
            }
        }

        public ulong Faultvaddr
        {
            get
            {
                return ((__Internal*)__Instance)->__faultvaddr;
            }

            set
            {
                ((__Internal*)__Instance)->__faultvaddr = value;
            }
        }
    }

    public unsafe partial class DarwinX86DebugState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal ulong __dr0;
            internal ulong __dr1;
            internal ulong __dr2;
            internal ulong __dr3;
            internal ulong __dr4;
            internal ulong __dr5;
            internal ulong __dr6;
            internal ulong __dr7;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86DebugState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86DebugState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86DebugState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86DebugState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86DebugState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86DebugState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86DebugState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86DebugState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86DebugState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86DebugState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Dr0
        {
            get
            {
                return ((__Internal*)__Instance)->__dr0;
            }

            set
            {
                ((__Internal*)__Instance)->__dr0 = value;
            }
        }

        public ulong Dr1
        {
            get
            {
                return ((__Internal*)__Instance)->__dr1;
            }

            set
            {
                ((__Internal*)__Instance)->__dr1 = value;
            }
        }

        public ulong Dr2
        {
            get
            {
                return ((__Internal*)__Instance)->__dr2;
            }

            set
            {
                ((__Internal*)__Instance)->__dr2 = value;
            }
        }

        public ulong Dr3
        {
            get
            {
                return ((__Internal*)__Instance)->__dr3;
            }

            set
            {
                ((__Internal*)__Instance)->__dr3 = value;
            }
        }

        public ulong Dr4
        {
            get
            {
                return ((__Internal*)__Instance)->__dr4;
            }

            set
            {
                ((__Internal*)__Instance)->__dr4 = value;
            }
        }

        public ulong Dr5
        {
            get
            {
                return ((__Internal*)__Instance)->__dr5;
            }

            set
            {
                ((__Internal*)__Instance)->__dr5 = value;
            }
        }

        public ulong Dr6
        {
            get
            {
                return ((__Internal*)__Instance)->__dr6;
            }

            set
            {
                ((__Internal*)__Instance)->__dr6 = value;
            }
        }

        public ulong Dr7
        {
            get
            {
                return ((__Internal*)__Instance)->__dr7;
            }

            set
            {
                ((__Internal*)__Instance)->__dr7 = value;
            }
        }
    }

    public unsafe partial class DarwinX86CpmuState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 128)]
        public partial struct __Internal
        {
            internal fixed ulong __ctrs[16];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86CpmuState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinX86CpmuState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86CpmuState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86CpmuState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86CpmuState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86CpmuState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86CpmuState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86CpmuState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86CpmuState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86CpmuState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong[] Ctrs
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ulong>(((__Internal*)__Instance)->__ctrs, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->__ctrs[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class DarwinMcontext32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 600)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinI386ExceptionState.__Internal __es;
            internal global::sentry.DarwinI386ThreadState.__Internal __ss;
            internal global::sentry.DarwinI386FloatState.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontext32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontext32>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontext32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontext32(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontext32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontext32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontext32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontext32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontext32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontext32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinI386ExceptionState Es
        {
            get
            {
                return global::sentry.DarwinI386ExceptionState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinI386ExceptionState.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinI386ThreadState Ss
        {
            get
            {
                return global::sentry.DarwinI386ThreadState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinI386ThreadState.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinI386FloatState Fs
        {
            get
            {
                return global::sentry.DarwinI386FloatState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinI386FloatState.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinMcontextAvx32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 792)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinI386ExceptionState.__Internal __es;
            internal global::sentry.DarwinI386ThreadState.__Internal __ss;
            internal global::sentry.DarwinI386AvxState.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx32>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx32(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinI386ExceptionState Es
        {
            get
            {
                return global::sentry.DarwinI386ExceptionState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinI386ExceptionState.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinI386ThreadState Ss
        {
            get
            {
                return global::sentry.DarwinI386ThreadState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinI386ThreadState.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinI386AvxState Fs
        {
            get
            {
                return global::sentry.DarwinI386AvxState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinI386AvxState.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinMcontextAvx512_32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1112)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinI386ExceptionState.__Internal __es;
            internal global::sentry.DarwinI386ThreadState.__Internal __ss;
            internal global::sentry.DarwinI386Avx512State.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx512_32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx512_32>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx512_32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_32(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx512_32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx512_32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx512_32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx512_32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx512_32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinI386ExceptionState Es
        {
            get
            {
                return global::sentry.DarwinI386ExceptionState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinI386ExceptionState.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinI386ThreadState Ss
        {
            get
            {
                return global::sentry.DarwinI386ThreadState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinI386ThreadState.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinI386Avx512State Fs
        {
            get
            {
                return global::sentry.DarwinI386Avx512State.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinI386Avx512State.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinMcontext64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 708)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinX86ExceptionState64.__Internal __es;
            internal global::sentry.DarwinX86ThreadState64.__Internal __ss;
            internal global::sentry.DarwinX86FloatState64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontext64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontext64>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontext64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontext64(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontext64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontext64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontext64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontext64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontext64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontext64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::sentry.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86ThreadState64 Ss
        {
            get
            {
                return global::sentry.DarwinX86ThreadState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinX86ThreadState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86FloatState64 Fs
        {
            get
            {
                return global::sentry.DarwinX86FloatState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinX86FloatState64.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinMcontext64Full : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 740)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinX86ExceptionState64.__Internal __es;
            internal global::sentry.DarwinX86ThreadFullState64.__Internal __ss;
            internal global::sentry.DarwinX86FloatState64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontext64Full> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontext64Full>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontext64Full __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontext64Full(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontext64Full __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontext64Full)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontext64Full __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontext64Full(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontext64Full(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontext64Full(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::sentry.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86ThreadFullState64 Ss
        {
            get
            {
                return global::sentry.DarwinX86ThreadFullState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinX86ThreadFullState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86FloatState64 Fs
        {
            get
            {
                return global::sentry.DarwinX86FloatState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinX86FloatState64.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinMcontextAvx64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1028)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinX86ExceptionState64.__Internal __es;
            internal global::sentry.DarwinX86ThreadState64.__Internal __ss;
            internal global::sentry.DarwinX86AvxState64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx64>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx64(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::sentry.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86ThreadState64 Ss
        {
            get
            {
                return global::sentry.DarwinX86ThreadState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinX86ThreadState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86AvxState64 Fs
        {
            get
            {
                return global::sentry.DarwinX86AvxState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinX86AvxState64.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinMcontextAvx64Full : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1060)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinX86ExceptionState64.__Internal __es;
            internal global::sentry.DarwinX86ThreadFullState64.__Internal __ss;
            internal global::sentry.DarwinX86AvxState64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx64Full> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx64Full>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx64Full __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx64Full(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx64Full __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx64Full)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx64Full __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx64Full(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx64Full(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx64Full(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::sentry.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86ThreadFullState64 Ss
        {
            get
            {
                return global::sentry.DarwinX86ThreadFullState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinX86ThreadFullState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86AvxState64 Fs
        {
            get
            {
                return global::sentry.DarwinX86AvxState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinX86AvxState64.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinMcontextAvx512_64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2628)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinX86ExceptionState64.__Internal __es;
            internal global::sentry.DarwinX86ThreadState64.__Internal __ss;
            internal global::sentry.DarwinX86Avx512State64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx512_64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx512_64>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx512_64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_64(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx512_64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx512_64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx512_64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx512_64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx512_64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::sentry.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86ThreadState64 Ss
        {
            get
            {
                return global::sentry.DarwinX86ThreadState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinX86ThreadState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86Avx512State64 Fs
        {
            get
            {
                return global::sentry.DarwinX86Avx512State64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinX86Avx512State64.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinMcontextAvx512_64Full : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2660)]
        public partial struct __Internal
        {
            internal global::sentry.DarwinX86ExceptionState64.__Internal __es;
            internal global::sentry.DarwinX86ThreadFullState64.__Internal __ss;
            internal global::sentry.DarwinX86Avx512State64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx512_64Full> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinMcontextAvx512_64Full>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx512_64Full __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_64Full(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx512_64Full __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx512_64Full)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx512_64Full __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_64Full(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx512_64Full(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx512_64Full(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::sentry.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::sentry.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86ThreadFullState64 Ss
        {
            get
            {
                return global::sentry.DarwinX86ThreadFullState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::sentry.DarwinX86ThreadFullState64.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinX86Avx512State64 Fs
        {
            get
            {
                return global::sentry.DarwinX86Avx512State64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::sentry.DarwinX86Avx512State64.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class DarwinSigaltstack : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal __IntPtr ss_sp;
            internal uint ss_size;
            internal int ss_flags;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinSigaltstack> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinSigaltstack>();

        protected bool __ownsNativeInstance;

        internal static DarwinSigaltstack __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinSigaltstack(native.ToPointer(), skipVTables);
        }

        internal static DarwinSigaltstack __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinSigaltstack)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinSigaltstack __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinSigaltstack(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinSigaltstack(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinSigaltstack(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr SsSp
        {
            get
            {
                return ((__Internal*)__Instance)->ss_sp;
            }

            set
            {
                ((__Internal*)__Instance)->ss_sp = (__IntPtr) value;
            }
        }

        public uint SsSize
        {
            get
            {
                return ((__Internal*)__Instance)->ss_size;
            }

            set
            {
                ((__Internal*)__Instance)->ss_size = value;
            }
        }

        public int SsFlags
        {
            get
            {
                return ((__Internal*)__Instance)->ss_flags;
            }

            set
            {
                ((__Internal*)__Instance)->ss_flags = value;
            }
        }
    }

    public unsafe partial class DarwinUcontext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal int uc_onstack;
            internal uint uc_sigmask;
            internal global::sentry.DarwinSigaltstack.__Internal uc_stack;
            internal __IntPtr uc_link;
            internal uint uc_mcsize;
            internal __IntPtr uc_mcontext;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinUcontext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.DarwinUcontext>();

        protected bool __ownsNativeInstance;

        internal static DarwinUcontext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinUcontext(native.ToPointer(), skipVTables);
        }

        internal static DarwinUcontext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinUcontext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinUcontext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinUcontext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinUcontext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinUcontext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int UcOnstack
        {
            get
            {
                return ((__Internal*)__Instance)->uc_onstack;
            }

            set
            {
                ((__Internal*)__Instance)->uc_onstack = value;
            }
        }

        public uint UcSigmask
        {
            get
            {
                return ((__Internal*)__Instance)->uc_sigmask;
            }

            set
            {
                ((__Internal*)__Instance)->uc_sigmask = value;
            }
        }

        public global::sentry.DarwinSigaltstack UcStack
        {
            get
            {
                return global::sentry.DarwinSigaltstack.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uc_stack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uc_stack = *(global::sentry.DarwinSigaltstack.__Internal*) value.__Instance;
            }
        }

        public global::sentry.DarwinUcontext UcLink
        {
            get
            {
                var __result0 = global::sentry.DarwinUcontext.__GetOrCreateInstance(((__Internal*)__Instance)->uc_link, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->uc_link = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint UcMcsize
        {
            get
            {
                return ((__Internal*)__Instance)->uc_mcsize;
            }

            set
            {
                ((__Internal*)__Instance)->uc_mcsize = value;
            }
        }

        public global::sentry.DarwinMcontext32 UcMcontext
        {
            get
            {
                var __result0 = global::sentry.DarwinMcontext32.__GetOrCreateInstance(((__Internal*)__Instance)->uc_mcontext, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->uc_mcontext = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial struct Sigval
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int sival_int;

            [FieldOffset(0)]
            internal __IntPtr sival_ptr;
        }

        private Sigval.__Internal __instance;
        internal Sigval.__Internal __Instance { get { return __instance; } }

        internal static Sigval __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigval(native.ToPointer(), skipVTables);
        }

        internal static Sigval __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigval(native, skipVTables);
        }

        private Sigval(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Sigval(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::sentry.Sigval.__Internal*) native;
        }

        public int SivalInt
        {
            get
            {
                return __instance.sival_int;
            }

            set
            {
                __instance.sival_int = value;
            }
        }

        public __IntPtr SivalPtr
        {
            get
            {
                return __instance.sival_ptr;
            }

            set
            {
                __instance.sival_ptr = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class Sigevent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal int sigev_notify;
            internal int sigev_signo;
            internal global::sentry.Sigval.__Internal sigev_value;
            internal __IntPtr sigev_notify_function;
            internal __IntPtr sigev_notify_attributes;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Sigevent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Sigevent>();

        protected bool __ownsNativeInstance;

        internal static Sigevent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigevent(native.ToPointer(), skipVTables);
        }

        internal static Sigevent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Sigevent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Sigevent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigevent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sigevent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sigevent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int SigevNotify
        {
            get
            {
                return ((__Internal*)__Instance)->sigev_notify;
            }

            set
            {
                ((__Internal*)__Instance)->sigev_notify = value;
            }
        }

        public int SigevSigno
        {
            get
            {
                return ((__Internal*)__Instance)->sigev_signo;
            }

            set
            {
                ((__Internal*)__Instance)->sigev_signo = value;
            }
        }

        public global::sentry.Sigval SigevValue
        {
            get
            {
                return global::sentry.Sigval.__CreateInstance(((__Internal*)__Instance)->sigev_value);
            }

            set
            {
                ((__Internal*)__Instance)->sigev_value = value.__Instance;
            }
        }

        public global::sentry.Delegates.Action_sentry_sigval___Internal SigevNotifyFunction
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->sigev_notify_function;
                return __ptr0 == IntPtr.Zero? null : (global::sentry.Delegates.Action_sentry_sigval___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::sentry.Delegates.Action_sentry_sigval___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->sigev_notify_function = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::sentry.OpaquePthreadAttrT SigevNotifyAttributes
        {
            get
            {
                var __result0 = global::sentry.OpaquePthreadAttrT.__GetOrCreateInstance(((__Internal*)__Instance)->sigev_notify_attributes, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->sigev_notify_attributes = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class Siginfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal int si_signo;
            internal int si_errno;
            internal int si_code;
            internal int si_pid;
            internal uint si_uid;
            internal int si_status;
            internal __IntPtr si_addr;
            internal global::sentry.Sigval.__Internal si_value;
            internal int si_band;
            internal fixed uint __pad[7];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Siginfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Siginfo>();

        protected bool __ownsNativeInstance;

        internal static Siginfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Siginfo(native.ToPointer(), skipVTables);
        }

        internal static Siginfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Siginfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Siginfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Siginfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Siginfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Siginfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int SiSigno
        {
            get
            {
                return ((__Internal*)__Instance)->si_signo;
            }

            set
            {
                ((__Internal*)__Instance)->si_signo = value;
            }
        }

        public int SiErrno
        {
            get
            {
                return ((__Internal*)__Instance)->si_errno;
            }

            set
            {
                ((__Internal*)__Instance)->si_errno = value;
            }
        }

        public int SiCode
        {
            get
            {
                return ((__Internal*)__Instance)->si_code;
            }

            set
            {
                ((__Internal*)__Instance)->si_code = value;
            }
        }

        public int SiPid
        {
            get
            {
                return ((__Internal*)__Instance)->si_pid;
            }

            set
            {
                ((__Internal*)__Instance)->si_pid = value;
            }
        }

        public uint SiUid
        {
            get
            {
                return ((__Internal*)__Instance)->si_uid;
            }

            set
            {
                ((__Internal*)__Instance)->si_uid = value;
            }
        }

        public int SiStatus
        {
            get
            {
                return ((__Internal*)__Instance)->si_status;
            }

            set
            {
                ((__Internal*)__Instance)->si_status = value;
            }
        }

        public __IntPtr SiAddr
        {
            get
            {
                return ((__Internal*)__Instance)->si_addr;
            }

            set
            {
                ((__Internal*)__Instance)->si_addr = (__IntPtr) value;
            }
        }

        public global::sentry.Sigval SiValue
        {
            get
            {
                return global::sentry.Sigval.__CreateInstance(((__Internal*)__Instance)->si_value);
            }

            set
            {
                ((__Internal*)__Instance)->si_value = value.__Instance;
            }
        }

        public int SiBand
        {
            get
            {
                return ((__Internal*)__Instance)->si_band;
            }

            set
            {
                ((__Internal*)__Instance)->si_band = value;
            }
        }

        public uint[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->__pad, 7);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 7; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    public unsafe partial struct SigactionU
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr __sa_handler;

            [FieldOffset(0)]
            internal __IntPtr __sa_sigaction;
        }

        private SigactionU.__Internal __instance;
        internal SigactionU.__Internal __Instance { get { return __instance; } }

        internal static SigactionU __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SigactionU(native.ToPointer(), skipVTables);
        }

        internal static SigactionU __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SigactionU(native, skipVTables);
        }

        private SigactionU(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private SigactionU(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::sentry.SigactionU.__Internal*) native;
        }

        public global::sentry.Delegates.Action_int SaHandler
        {
            get
            {
                var __ptr0 = __instance.__sa_handler;
                return __ptr0 == IntPtr.Zero? null : (global::sentry.Delegates.Action_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::sentry.Delegates.Action_int));
            }

            set
            {
                __instance.__sa_handler = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::sentry.Delegates.Action_int___IntPtr___IntPtr SaSigaction
        {
            get
            {
                var __ptr0 = __instance.__sa_sigaction;
                return __ptr0 == IntPtr.Zero? null : (global::sentry.Delegates.Action_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::sentry.Delegates.Action_int___IntPtr___IntPtr));
            }

            set
            {
                __instance.__sa_sigaction = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class Sigaction : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::sentry.SigactionU.__Internal __sigaction_u;
            internal __IntPtr sa_tramp;
            internal uint sa_mask;
            internal int sa_flags;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Sigaction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Sigaction>();

        protected bool __ownsNativeInstance;

        internal static Sigaction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigaction(native.ToPointer(), skipVTables);
        }

        internal static Sigaction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Sigaction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Sigaction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigaction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sigaction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sigaction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.SigactionU SigactionU
        {
            get
            {
                return global::sentry.SigactionU.__CreateInstance(((__Internal*)__Instance)->__sigaction_u);
            }

            set
            {
                ((__Internal*)__Instance)->__sigaction_u = value.__Instance;
            }
        }

        public global::sentry.Delegates.Action___IntPtr_int_int___IntPtr___IntPtr SaTramp
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->sa_tramp;
                return __ptr0 == IntPtr.Zero? null : (global::sentry.Delegates.Action___IntPtr_int_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::sentry.Delegates.Action___IntPtr_int_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->sa_tramp = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public uint SaMask
        {
            get
            {
                return ((__Internal*)__Instance)->sa_mask;
            }

            set
            {
                ((__Internal*)__Instance)->sa_mask = value;
            }
        }

        public int SaFlags
        {
            get
            {
                return ((__Internal*)__Instance)->sa_flags;
            }

            set
            {
                ((__Internal*)__Instance)->sa_flags = value;
            }
        }
    }

    public unsafe partial class sigaction : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::sentry.SigactionU.__Internal __sigaction_u;
            internal uint sa_mask;
            internal int sa_flags;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.sigaction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.sigaction>();

        protected bool __ownsNativeInstance;

        internal static sigaction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new sigaction(native.ToPointer(), skipVTables);
        }

        internal static sigaction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (sigaction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static sigaction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new sigaction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private sigaction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected sigaction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.SigactionU SigactionU
        {
            get
            {
                return global::sentry.SigactionU.__CreateInstance(((__Internal*)__Instance)->__sigaction_u);
            }

            set
            {
                ((__Internal*)__Instance)->__sigaction_u = value.__Instance;
            }
        }

        public uint SaMask
        {
            get
            {
                return ((__Internal*)__Instance)->sa_mask;
            }

            set
            {
                ((__Internal*)__Instance)->sa_mask = value;
            }
        }

        public int SaFlags
        {
            get
            {
                return ((__Internal*)__Instance)->sa_flags;
            }

            set
            {
                ((__Internal*)__Instance)->sa_flags = value;
            }
        }
    }

    public unsafe partial class Sigvec : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal __IntPtr sv_handler;
            internal int sv_mask;
            internal int sv_flags;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Sigvec> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Sigvec>();

        protected bool __ownsNativeInstance;

        internal static Sigvec __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigvec(native.ToPointer(), skipVTables);
        }

        internal static Sigvec __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Sigvec)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Sigvec __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigvec(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sigvec(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sigvec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::sentry.Delegates.Action_int SvHandler
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->sv_handler;
                return __ptr0 == IntPtr.Zero? null : (global::sentry.Delegates.Action_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::sentry.Delegates.Action_int));
            }

            set
            {
                ((__Internal*)__Instance)->sv_handler = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public int SvMask
        {
            get
            {
                return ((__Internal*)__Instance)->sv_mask;
            }

            set
            {
                ((__Internal*)__Instance)->sv_mask = value;
            }
        }

        public int SvFlags
        {
            get
            {
                return ((__Internal*)__Instance)->sv_flags;
            }

            set
            {
                ((__Internal*)__Instance)->sv_flags = value;
            }
        }
    }

    public unsafe partial class Sigstack : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr ss_sp;
            internal int ss_onstack;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Sigstack> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.Sigstack>();

        protected bool __ownsNativeInstance;

        internal static Sigstack __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigstack(native.ToPointer(), skipVTables);
        }

        internal static Sigstack __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Sigstack)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Sigstack __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigstack(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sigstack(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sigstack(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* SsSp
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->ss_sp;
            }

            set
            {
                ((__Internal*)__Instance)->ss_sp = (__IntPtr) value;
            }
        }

        public int SsOnstack
        {
            get
            {
                return ((__Internal*)__Instance)->ss_onstack;
            }

            set
            {
                ((__Internal*)__Instance)->ss_onstack = value;
            }
        }
    }

    /// <summary>Represents a sentry protocol value.</summary>
    /// <remarks>
    /// <para>The members of this type should never be accessed.  They are only here</para>
    /// <para>so that alignment for the type can be properly determined.</para>
    /// <para>Values must be released with `sentry_value_decref`.  This lowers the</para>
    /// <para>internal refcount by one.  If the refcount hits zero it's freed.  Some</para>
    /// <para>values like primitives have no refcount (like null) so operations on</para>
    /// <para>those are no-ops.</para>
    /// <para>In addition values can be frozen.  Some values like primitives are always</para>
    /// <para>frozen but lists and dicts are not and can be frozen on demand.  This</para>
    /// <para>automatically happens for some shared values in the event payload like</para>
    /// <para>the module list.</para>
    /// </remarks>
    public unsafe partial struct SentryValueU
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong _bits;

            [FieldOffset(0)]
            internal double _double;

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "_ZN14sentry_value_uC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        private SentryValueU.__Internal __instance;
        internal SentryValueU.__Internal __Instance { get { return __instance; } }

        internal static SentryValueU __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryValueU(native.ToPointer(), skipVTables);
        }

        internal static SentryValueU __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryValueU(native, skipVTables);
        }

        private SentryValueU(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private SentryValueU(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::sentry.SentryValueU.__Internal*) native;
        }

        public SentryValueU(global::sentry.SentryValueU _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public ulong Bits
        {
            get
            {
                return __instance._bits;
            }

            set
            {
                __instance._bits = value;
            }
        }

        public double Double
        {
            get
            {
                return __instance._double;
            }

            set
            {
                __instance._double = value;
            }
        }
    }

    /// <summary>
    /// <para>This represents the OS dependent user context in the case of a crash, and can</para>
    /// <para>be used to manually capture a crash.</para>
    /// </summary>
    public unsafe partial class SentryUcontextS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int signum;
            internal __IntPtr siginfo;
            internal __IntPtr user_context;

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "_ZN17sentry_ucontext_sC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryUcontextS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryUcontextS>();

        protected bool __ownsNativeInstance;

        internal static SentryUcontextS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryUcontextS(native.ToPointer(), skipVTables);
        }

        internal static SentryUcontextS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryUcontextS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryUcontextS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryUcontextS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryUcontextS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryUcontextS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SentryUcontextS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::sentry.SentryUcontextS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SentryUcontextS(global::sentry.SentryUcontextS _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::sentry.SentryUcontextS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::sentry.SentryUcontextS.__Internal*) __Instance) = *((global::sentry.SentryUcontextS.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Signum
        {
            get
            {
                return ((__Internal*)__Instance)->signum;
            }

            set
            {
                ((__Internal*)__Instance)->signum = value;
            }
        }

        public global::sentry.Siginfo Siginfo
        {
            get
            {
                var __result0 = global::sentry.Siginfo.__GetOrCreateInstance(((__Internal*)__Instance)->siginfo, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->siginfo = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::sentry.DarwinUcontext UserContext
        {
            get
            {
                var __result0 = global::sentry.DarwinUcontext.__GetOrCreateInstance(((__Internal*)__Instance)->user_context, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->user_context = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>A UUID</summary>
    public unsafe partial class SentryUuidS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed sbyte bytes[16];

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "_ZN13sentry_uuid_sC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryUuidS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::sentry.SentryUuidS>();

        protected bool __ownsNativeInstance;

        internal static SentryUuidS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryUuidS(native.ToPointer(), skipVTables);
        }

        internal static SentryUuidS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryUuidS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryUuidS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryUuidS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryUuidS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryUuidS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SentryUuidS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::sentry.SentryUuidS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SentryUuidS(global::sentry.SentryUuidS _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::sentry.SentryUuidS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::sentry.SentryUuidS.__Internal*) __Instance) = *((global::sentry.SentryUuidS.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Bytes
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->bytes, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->bytes[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class sentry
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "__sigbits", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Sigbits(int __signo);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_malloc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryMalloc(uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryFree(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_incref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryValueIncref(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_decref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryValueDecref(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_refcount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SentryValueRefcount(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_freeze", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryValueFreeze(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_is_frozen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueIsFrozen(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_null", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewNull();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_int32", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewInt32(int value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_double", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewDouble(double value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_bool", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewBool(int value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewString([MarshalAs(UnmanagedType.LPUTF8Str)] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewList();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_object", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewObject();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueTypeT SentryValueGetType(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_set_by_key", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueSetByKey(global::sentry.SentryValueU.__Internal value, [MarshalAs(UnmanagedType.LPUTF8Str)] string k, global::sentry.SentryValueU.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_remove_by_key", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueRemoveByKey(global::sentry.SentryValueU.__Internal value, [MarshalAs(UnmanagedType.LPUTF8Str)] string k);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_append", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueAppend(global::sentry.SentryValueU.__Internal value, global::sentry.SentryValueU.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_set_by_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueSetByIndex(global::sentry.SentryValueU.__Internal value, uint index, global::sentry.SentryValueU.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_remove_by_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueRemoveByIndex(global::sentry.SentryValueU.__Internal value, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_get_by_key", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueGetByKey(global::sentry.SentryValueU.__Internal value, [MarshalAs(UnmanagedType.LPUTF8Str)] string k);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_get_by_key_owned", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueGetByKeyOwned(global::sentry.SentryValueU.__Internal value, [MarshalAs(UnmanagedType.LPUTF8Str)] string k);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_get_by_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueGetByIndex(global::sentry.SentryValueU.__Internal value, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_get_by_index_owned", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueGetByIndexOwned(global::sentry.SentryValueU.__Internal value, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_get_length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SentryValueGetLength(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_as_int32", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueAsInt32(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_as_double", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double SentryValueAsDouble(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_as_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryValueAsString(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_is_true", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueIsTrue(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_is_null", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueIsNull(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_to_json", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* SentryValueToJson(global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewEvent();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_message_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewMessageEvent(global::sentry.SentryLevelE level, [MarshalAs(UnmanagedType.LPUTF8Str)] string logger, [MarshalAs(UnmanagedType.LPUTF8Str)] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_new_breadcrumb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryValueNewBreadcrumb([MarshalAs(UnmanagedType.LPUTF8Str)] string type, [MarshalAs(UnmanagedType.LPUTF8Str)] string message);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_value_to_msgpack", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* SentryValueToMsgpack(global::sentry.SentryValueU.__Internal value, uint* size_out);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_event_value_add_stacktrace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryEventValueAddStacktrace(global::sentry.SentryValueU.__Internal @event, void** ips, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_unwind_stack", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SentryUnwindStack(__IntPtr addr, void** stacktrace_out, uint max_len);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_unwind_stack_from_ucontext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SentryUnwindStackFromUcontext(__IntPtr uctx, void** stacktrace_out, uint max_len);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_uuid_nil", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUuidNil(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_uuid_new_v4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUuidNewV4(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_uuid_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUuidFromString(__IntPtr @return, [MarshalAs(UnmanagedType.LPUTF8Str)] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_uuid_from_bytes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUuidFromBytes(__IntPtr @return, sbyte[] bytes);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_uuid_is_nil", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryUuidIsNil(__IntPtr uuid);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_uuid_as_bytes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUuidAsBytes(__IntPtr uuid, sbyte[] bytes);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_uuid_as_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUuidAsString(__IntPtr uuid, sbyte[] str);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_envelope_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryEnvelopeFree(__IntPtr envelope);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_envelope_get_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryEnvelopeGetEvent(__IntPtr envelope);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_envelope_serialize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* SentryEnvelopeSerialize(__IntPtr envelope, uint* size_out);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_envelope_write_to_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryEnvelopeWriteToFile(__IntPtr envelope, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_transport_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryTransportNew(__IntPtr send_func);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_transport_set_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportSetState(__IntPtr transport, __IntPtr state);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_transport_set_free_func", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportSetFreeFunc(__IntPtr transport, __IntPtr free_func);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_transport_set_startup_func", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportSetStartupFunc(__IntPtr transport, __IntPtr startup_func);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_transport_set_shutdown_func", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportSetShutdownFunc(__IntPtr transport, __IntPtr shutdown_func);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_transport_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportFree(__IntPtr transport);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_new_function_transport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryNewFunctionTransport(__IntPtr func, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsNew();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsFree(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_transport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetTransport(__IntPtr opts, __IntPtr transport);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_before_send", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetBeforeSend(__IntPtr opts, __IntPtr func, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_dsn", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetDsn(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string dsn);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_dsn", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetDsn(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_sample_rate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetSampleRate(__IntPtr opts, double sample_rate);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_sample_rate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double SentryOptionsGetSampleRate(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetRelease(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string release);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetRelease(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_environment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetEnvironment(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string environment);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_environment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetEnvironment(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_dist", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetDist(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string dist);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_dist", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetDist(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_http_proxy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetHttpProxy(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string proxy);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_http_proxy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetHttpProxy(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_ca_certs", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetCaCerts(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_ca_certs", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetCaCerts(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_transport_thread_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetTransportThreadName(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_transport_thread_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetTransportThreadName(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_debug", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetDebug(__IntPtr opts, int debug);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_debug", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryOptionsGetDebug(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_auto_session_tracking", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetAutoSessionTracking(__IntPtr opts, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_auto_session_tracking", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryOptionsGetAutoSessionTracking(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_require_user_consent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetRequireUserConsent(__IntPtr opts, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_require_user_consent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryOptionsGetRequireUserConsent(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_symbolize_stacktraces", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetSymbolizeStacktraces(__IntPtr opts, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_get_symbolize_stacktraces", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryOptionsGetSymbolizeStacktraces(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_add_attachment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsAddAttachment(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_handler_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetHandlerPath(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_database_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetDatabasePath(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_options_set_system_crash_reporter_enabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetSystemCrashReporterEnabled(__IntPtr opts, int enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryInit(__IntPtr options);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_shutdown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryShutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_get_modules_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryValueU.__Internal SentryGetModulesList();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_clear_modulecache", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryClearModulecache();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_user_consent_give", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUserConsentGive();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_user_consent_revoke", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUserConsentRevoke();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_user_consent_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUserConsentReset();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_user_consent_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::sentry.SentryUserConsentT SentryUserConsentGet();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_capture_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryCaptureEvent(__IntPtr @return, global::sentry.SentryValueU.__Internal @event);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_handle_exception", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryHandleException(__IntPtr uctx);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_add_breadcrumb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryAddBreadcrumb(global::sentry.SentryValueU.__Internal breadcrumb);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_set_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetUser(global::sentry.SentryValueU.__Internal user);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_remove_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveUser();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_set_tag", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetTag([MarshalAs(UnmanagedType.LPUTF8Str)] string key, [MarshalAs(UnmanagedType.LPUTF8Str)] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_remove_tag", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveTag([MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_set_extra", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetExtra([MarshalAs(UnmanagedType.LPUTF8Str)] string key, global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_remove_extra", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveExtra([MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_set_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetContext([MarshalAs(UnmanagedType.LPUTF8Str)] string key, global::sentry.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_remove_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveContext([MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_set_fingerprint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetFingerprint([MarshalAs(UnmanagedType.LPUTF8Str)] string fingerprint);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_remove_fingerprint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveFingerprint();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_set_transaction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetTransaction([MarshalAs(UnmanagedType.LPUTF8Str)] string transaction);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_remove_transaction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveTransaction();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_set_level", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetLevel(global::sentry.SentryLevelE level);

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_start_session", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryStartSession();

            [SuppressUnmanagedCodeSecurity, DllImport("sentry", EntryPoint = "sentry_end_session", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryEndSession();
        }

        public static int Sigbits(int __signo)
        {
            var __ret = __Internal.Sigbits(__signo);
            return __ret;
        }

        /// <summary>Allocates memory with the underlying allocator.</summary>
        public static __IntPtr SentryMalloc(uint size)
        {
            var __ret = __Internal.SentryMalloc(size);
            return __ret;
        }

        /// <summary>Releases memory allocated from the underlying allocator.</summary>
        public static void SentryFree(__IntPtr ptr)
        {
            __Internal.SentryFree(ptr);
        }

        /// <summary>Increments the reference count on the value.</summary>
        public static void SentryValueIncref(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            __Internal.SentryValueIncref(__arg0);
        }

        /// <summary>Decrements the reference count on the value.</summary>
        public static void SentryValueDecref(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            __Internal.SentryValueDecref(__arg0);
        }

        /// <summary>Returns the refcount of a value.</summary>
        public static uint SentryValueRefcount(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueRefcount(__arg0);
            return __ret;
        }

        /// <summary>Freezes a value.</summary>
        public static void SentryValueFreeze(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            __Internal.SentryValueFreeze(__arg0);
        }

        /// <summary>Checks if a value is frozen.</summary>
        public static int SentryValueIsFrozen(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueIsFrozen(__arg0);
            return __ret;
        }

        /// <summary>Creates a null value.</summary>
        public static global::sentry.SentryValueU SentryValueNewNull()
        {
            var __ret = __Internal.SentryValueNewNull();
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new 32-bit signed integer value.</summary>
        public static global::sentry.SentryValueU SentryValueNewInt32(int value)
        {
            var __ret = __Internal.SentryValueNewInt32(value);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new double value.</summary>
        public static global::sentry.SentryValueU SentryValueNewDouble(double value)
        {
            var __ret = __Internal.SentryValueNewDouble(value);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new boolen value.</summary>
        public static global::sentry.SentryValueU SentryValueNewBool(int value)
        {
            var __ret = __Internal.SentryValueNewBool(value);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new null terminated string.</summary>
        public static global::sentry.SentryValueU SentryValueNewString(string value)
        {
            var __ret = __Internal.SentryValueNewString(value);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new list value.</summary>
        public static global::sentry.SentryValueU SentryValueNewList()
        {
            var __ret = __Internal.SentryValueNewList();
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new object.</summary>
        public static global::sentry.SentryValueU SentryValueNewObject()
        {
            var __ret = __Internal.SentryValueNewObject();
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Returns the type of the value passed.</summary>
        public static global::sentry.SentryValueTypeT SentryValueGetType(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetType(__arg0);
            return __ret;
        }

        /// <summary>Sets a key to a value in the map.</summary>
        /// <remarks>
        /// <para>This moves the ownership of the value into the map.  The caller does not</para>
        /// <para>have to call `sentry_value_decref` on it.</para>
        /// </remarks>
        public static int SentryValueSetByKey(global::sentry.SentryValueU value, string k, global::sentry.SentryValueU v)
        {
            var __arg0 = value.__Instance;
            var __arg2 = v.__Instance;
            var __ret = __Internal.SentryValueSetByKey(__arg0, k, __arg2);
            return __ret;
        }

        /// <summary>This removes a value from the map by key.</summary>
        public static int SentryValueRemoveByKey(global::sentry.SentryValueU value, string k)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueRemoveByKey(__arg0, k);
            return __ret;
        }

        /// <summary>Appends a value to a list.</summary>
        /// <remarks>
        /// <para>This moves the ownership of the value into the list.  The caller does not</para>
        /// <para>have to call `sentry_value_decref` on it.</para>
        /// </remarks>
        public static int SentryValueAppend(global::sentry.SentryValueU value, global::sentry.SentryValueU v)
        {
            var __arg0 = value.__Instance;
            var __arg1 = v.__Instance;
            var __ret = __Internal.SentryValueAppend(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Inserts a value into the list at a certain position.</summary>
        /// <remarks>
        /// <para>This moves the ownership of the value into the list.  The caller does not</para>
        /// <para>have to call `sentry_value_decref` on it.</para>
        /// <para>If the list is shorter than the given index it's automatically extended</para>
        /// <para>and filled with `null` values.</para>
        /// </remarks>
        public static int SentryValueSetByIndex(global::sentry.SentryValueU value, uint index, global::sentry.SentryValueU v)
        {
            var __arg0 = value.__Instance;
            var __arg2 = v.__Instance;
            var __ret = __Internal.SentryValueSetByIndex(__arg0, index, __arg2);
            return __ret;
        }

        /// <summary>This removes a value from the list by index.</summary>
        public static int SentryValueRemoveByIndex(global::sentry.SentryValueU value, uint index)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueRemoveByIndex(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Looks up a value in a map by key.  If missing a null value is returned.</para>
        /// <para>The returned value is borrowed.</para>
        /// </summary>
        public static global::sentry.SentryValueU SentryValueGetByKey(global::sentry.SentryValueU value, string k)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetByKey(__arg0, k);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Looks up a value in a map by key.  If missing a null value is returned.</para>
        /// <para>The returned value is owned.</para>
        /// </summary>
        /// <remarks>
        /// <para>If the caller no longer needs the value it must be released with</para>
        /// <para>`sentry_value_decref`.</para>
        /// </remarks>
        public static global::sentry.SentryValueU SentryValueGetByKeyOwned(global::sentry.SentryValueU value, string k)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetByKeyOwned(__arg0, k);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Looks up a value in a list by index.  If missing a null value is returned.</para>
        /// <para>The returned value is borrowed.</para>
        /// </summary>
        public static global::sentry.SentryValueU SentryValueGetByIndex(global::sentry.SentryValueU value, uint index)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetByIndex(__arg0, index);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Looks up a value in a list by index.  If missing a null value is</para>
        /// <para>returned. The returned value is owned.</para>
        /// </summary>
        /// <remarks>
        /// <para>If the caller no longer needs the value it must be released with</para>
        /// <para>`sentry_value_decref`.</para>
        /// </remarks>
        public static global::sentry.SentryValueU SentryValueGetByIndexOwned(global::sentry.SentryValueU value, uint index)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetByIndexOwned(__arg0, index);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Returns the length of the given map or list.</summary>
        /// <remarks>If an item is not a list or map the return value is 0.</remarks>
        public static uint SentryValueGetLength(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetLength(__arg0);
            return __ret;
        }

        /// <summary>Converts a value into a 32bit signed integer.</summary>
        public static int SentryValueAsInt32(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueAsInt32(__arg0);
            return __ret;
        }

        /// <summary>Converts a value into a double value.</summary>
        public static double SentryValueAsDouble(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueAsDouble(__arg0);
            return __ret;
        }

        /// <summary>Returns the value as c string.</summary>
        public static string SentryValueAsString(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueAsString(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Returns `true` if the value is boolean true.</summary>
        public static int SentryValueIsTrue(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueIsTrue(__arg0);
            return __ret;
        }

        /// <summary>Returns `true` if the value is null.</summary>
        public static int SentryValueIsNull(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueIsNull(__arg0);
            return __ret;
        }

        /// <summary>Serialize a sentry value to JSON.</summary>
        /// <remarks>
        /// <para>The string is freshly allocated and must be freed with</para>
        /// <para>`sentry_string_free`.</para>
        /// </remarks>
        public static sbyte* SentryValueToJson(global::sentry.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueToJson(__arg0);
            return __ret;
        }

        /// <summary>Creates a new empty event value.</summary>
        public static global::sentry.SentryValueU SentryValueNewEvent()
        {
            var __ret = __Internal.SentryValueNewEvent();
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new message event value.</summary>
        /// <remarks>`logger` can be NULL to omit the logger value.</remarks>
        public static global::sentry.SentryValueU SentryValueNewMessageEvent(global::sentry.SentryLevelE level, string logger, string text)
        {
            var __ret = __Internal.SentryValueNewMessageEvent(level, logger, text);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new breadcrumb with a specific type and message.</summary>
        /// <remarks>Either parameter can be NULL in which case no such attributes is created.</remarks>
        public static global::sentry.SentryValueU SentryValueNewBreadcrumb(string type, string message)
        {
            var __ret = __Internal.SentryValueNewBreadcrumb(type, message);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Serialize a sentry value to msgpack.</summary>
        /// <remarks>
        /// <para>The string is freshly allocated and must be freed with</para>
        /// <para>`sentry_string_free`.  Since msgpack is not zero terminated</para>
        /// <para>the size is written to the `size_out` parameter.</para>
        /// </remarks>
        public static sbyte* SentryValueToMsgpack(global::sentry.SentryValueU value, ref uint size_out)
        {
            var __arg0 = value.__Instance;
            fixed (uint* __size_out1 = &size_out)
            {
                var __arg1 = __size_out1;
                var __ret = __Internal.SentryValueToMsgpack(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Adds a stacktrace to an event.</summary>
        /// <remarks>
        /// <para>If `ips` is NULL the current stacktrace is captured, otherwise `len`</para>
        /// <para>stacktrace instruction pointers are attached to the event.</para>
        /// </remarks>
        public static void SentryEventValueAddStacktrace(global::sentry.SentryValueU @event, void** ips, uint len)
        {
            var __arg0 = @event.__Instance;
            __Internal.SentryEventValueAddStacktrace(__arg0, ips, len);
        }

        /// <summary>Unwinds the stack from the given address.</summary>
        /// <remarks>
        /// <para>If the address is given in `addr` the stack is unwound form there.</para>
        /// <para>Otherwise (NULL is passed) the current instruction pointer is used as</para>
        /// <para>start address. The stacktrace is written to `stacktrace_out` with upt o</para>
        /// <para>`max_len` frames being written.  The actual number of unwound stackframes</para>
        /// <para>is returned.</para>
        /// </remarks>
        public static uint SentryUnwindStack(__IntPtr addr, void** stacktrace_out, uint max_len)
        {
            var __ret = __Internal.SentryUnwindStack(addr, stacktrace_out, max_len);
            return __ret;
        }

        /// <summary>Unwinds the stack from the given context.</summary>
        /// <remarks>
        /// <para>The stacktrace is written to `stacktrace_out` with upt o `max_len` frames</para>
        /// <para>being written.  The actual number of unwound stackframes is returned.</para>
        /// </remarks>
        public static uint SentryUnwindStackFromUcontext(global::sentry.SentryUcontextS uctx, void** stacktrace_out, uint max_len)
        {
            var __arg0 = uctx is null ? __IntPtr.Zero : uctx.__Instance;
            var __ret = __Internal.SentryUnwindStackFromUcontext(__arg0, stacktrace_out, max_len);
            return __ret;
        }

        /// <summary>Creates the nil uuid.</summary>
        public static global::sentry.SentryUuidS SentryUuidNil()
        {
            var __ret = new global::sentry.SentryUuidS.__Internal();
            __Internal.SentryUuidNil(new IntPtr(&__ret));
            return global::sentry.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Creates a new uuid4.</summary>
        public static global::sentry.SentryUuidS SentryUuidNewV4()
        {
            var __ret = new global::sentry.SentryUuidS.__Internal();
            __Internal.SentryUuidNewV4(new IntPtr(&__ret));
            return global::sentry.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Parses a uuid from a string.</summary>
        public static global::sentry.SentryUuidS SentryUuidFromString(string str)
        {
            var __ret = new global::sentry.SentryUuidS.__Internal();
            __Internal.SentryUuidFromString(new IntPtr(&__ret), str);
            return global::sentry.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Creates a uuid from bytes.</summary>
        public static global::sentry.SentryUuidS SentryUuidFromBytes(sbyte[] bytes)
        {
            if (bytes == null || bytes.Length != 16)
                throw new ArgumentOutOfRangeException("bytes", "The dimensions of the provided array don't match the required size.");
            var __ret = new global::sentry.SentryUuidS.__Internal();
            __Internal.SentryUuidFromBytes(new IntPtr(&__ret), bytes);
            return global::sentry.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Checks if the uuid is nil.</summary>
        public static int SentryUuidIsNil(global::sentry.SentryUuidS uuid)
        {
            var __arg0 = uuid is null ? __IntPtr.Zero : uuid.__Instance;
            var __ret = __Internal.SentryUuidIsNil(__arg0);
            return __ret;
        }

        /// <summary>Returns the bytes of the uuid.</summary>
        public static void SentryUuidAsBytes(global::sentry.SentryUuidS uuid, sbyte[] bytes)
        {
            var __arg0 = uuid is null ? __IntPtr.Zero : uuid.__Instance;
            if (bytes == null || bytes.Length != 16)
                throw new ArgumentOutOfRangeException("bytes", "The dimensions of the provided array don't match the required size.");
            __Internal.SentryUuidAsBytes(__arg0, bytes);
        }

        /// <summary>Formats the uuid into a string buffer.</summary>
        public static void SentryUuidAsString(global::sentry.SentryUuidS uuid, sbyte[] str)
        {
            var __arg0 = uuid is null ? __IntPtr.Zero : uuid.__Instance;
            if (str == null || str.Length != 37)
                throw new ArgumentOutOfRangeException("str", "The dimensions of the provided array don't match the required size.");
            __Internal.SentryUuidAsString(__arg0, str);
        }

        /// <summary>Frees an envelope.</summary>
        public static void SentryEnvelopeFree(global::sentry.SentryEnvelopeS envelope)
        {
            var __arg0 = envelope is null ? __IntPtr.Zero : envelope.__Instance;
            __Internal.SentryEnvelopeFree(__arg0);
        }

        /// <summary>Given an envelope returns the embedded event if there is one.</summary>
        /// <remarks>This returns a borrowed value to the event in the envelope.</remarks>
        public static global::sentry.SentryValueU SentryEnvelopeGetEvent(global::sentry.SentryEnvelopeS envelope)
        {
            var __arg0 = envelope is null ? __IntPtr.Zero : envelope.__Instance;
            var __ret = __Internal.SentryEnvelopeGetEvent(__arg0);
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Serializes the envelope.</summary>
        /// <remarks>The return value needs to be freed with sentry_string_free().</remarks>
        public static sbyte* SentryEnvelopeSerialize(global::sentry.SentryEnvelopeS envelope, ref uint size_out)
        {
            var __arg0 = envelope is null ? __IntPtr.Zero : envelope.__Instance;
            fixed (uint* __size_out1 = &size_out)
            {
                var __arg1 = __size_out1;
                var __ret = __Internal.SentryEnvelopeSerialize(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Serializes the envelope into a file.</summary>
        /// <remarks>
        /// <para>`path` is assumed to be in platform-specific filesystem path encoding.</para>
        /// <para>Returns 0 on success.</para>
        /// </remarks>
        public static int SentryEnvelopeWriteToFile(global::sentry.SentryEnvelopeS envelope, string path)
        {
            var __arg0 = envelope is null ? __IntPtr.Zero : envelope.__Instance;
            var __ret = __Internal.SentryEnvelopeWriteToFile(__arg0, path);
            return __ret;
        }

        /// <summary>Creates a new transport with an initial `send_func`.</summary>
        public static global::sentry.SentryTransportS SentryTransportNew(global::sentry.Delegates.Action___IntPtr___IntPtr send_func)
        {
            var __arg0 = send_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(send_func);
            var __ret = __Internal.SentryTransportNew(__arg0);
            var __result0 = global::sentry.SentryTransportS.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Sets the transport `state`.</summary>
        /// <remarks>
        /// <para>If the state is owned by the transport and needs to be freed, use</para>
        /// <para>`sentry_transport_set_free_func` to set an appropriate hook.</para>
        /// </remarks>
        public static void SentryTransportSetState(global::sentry.SentryTransportS transport, __IntPtr state)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            __Internal.SentryTransportSetState(__arg0, state);
        }

        /// <summary>Sets the transport hook to free the transport `state`.</summary>
        public static void SentryTransportSetFreeFunc(global::sentry.SentryTransportS transport, global::sentry.Delegates.Action___IntPtr free_func)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            var __arg1 = free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_func);
            __Internal.SentryTransportSetFreeFunc(__arg0, __arg1);
        }

        /// <summary>Sets the transport startup hook.</summary>
        /// <remarks>
        /// <para>This hook is called from within `sentry_init` and will get a reference to the</para>
        /// <para>options which can be used to initialize a transports internal state.</para>
        /// <para>It should return `0` on success. A failure will bubble up to `sentry_init`.</para>
        /// </remarks>
        public static void SentryTransportSetStartupFunc(global::sentry.SentryTransportS transport, global::sentry.Delegates.Func_int___IntPtr___IntPtr startup_func)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            var __arg1 = startup_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(startup_func);
            __Internal.SentryTransportSetStartupFunc(__arg0, __arg1);
        }

        /// <summary>Sets the transport shutdown hook.</summary>
        /// <remarks>
        /// <para>This hook will receive a millisecond-resolution timeout.</para>
        /// <para>It should return `0` on success in case all the pending envelopes have been</para>
        /// <para>sent within the timeout, or `1` if the timeout was hit.</para>
        /// </remarks>
        public static void SentryTransportSetShutdownFunc(global::sentry.SentryTransportS transport, global::sentry.Delegates.Func_int_ulong___IntPtr shutdown_func)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            var __arg1 = shutdown_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(shutdown_func);
            __Internal.SentryTransportSetShutdownFunc(__arg0, __arg1);
        }

        /// <summary>Generic way to free a transport.</summary>
        public static void SentryTransportFree(global::sentry.SentryTransportS transport)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            __Internal.SentryTransportFree(__arg0);
        }

        /// <summary>Create a new function transport.</summary>
        /// <remarks>
        /// <para>It is a convenience function which works with a borrowed `data`, and will</para>
        /// <para>automatically free the envelope, so the user provided function does not need</para>
        /// <para>to do that.</para>
        /// <para>This function is *deprecated* and will be removed in a future version.</para>
        /// <para>It is here for backwards compatibility. Users should migrate to the</para>
        /// <para>`sentry_transport_new` API.</para>
        /// </remarks>
        public static global::sentry.SentryTransportS SentryNewFunctionTransport(global::sentry.Delegates.Action___IntPtr___IntPtr func, __IntPtr data)
        {
            var __arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            var __ret = __Internal.SentryNewFunctionTransport(__arg0, data);
            var __result0 = global::sentry.SentryTransportS.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Creates a new options struct.</para>
        /// <para>Can be freed with `sentry_options_free`.</para>
        /// </summary>
        public static global::sentry.SentryOptionsS SentryOptionsNew()
        {
            var __ret = __Internal.SentryOptionsNew();
            var __result0 = global::sentry.SentryOptionsS.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Deallocates previously allocated sentry options.</summary>
        public static void SentryOptionsFree(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsFree(__arg0);
        }

        /// <summary>Sets a transport.</summary>
        public static void SentryOptionsSetTransport(global::sentry.SentryOptionsS opts, global::sentry.SentryTransportS transport)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __arg1 = transport is null ? __IntPtr.Zero : transport.__Instance;
            __Internal.SentryOptionsSetTransport(__arg0, __arg1);
        }

        /// <summary>Sets the `before_send` callback.</summary>
        /// <remarks>See the `sentry_event_function_t` typedef above for more information.</remarks>
        public static void SentryOptionsSetBeforeSend(global::sentry.SentryOptionsS opts, global::sentry.SentryEventFunctionT func, __IntPtr data)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __arg1 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            __Internal.SentryOptionsSetBeforeSend(__arg0, __arg1, data);
        }

        /// <summary>Sets the DSN.</summary>
        public static void SentryOptionsSetDsn(global::sentry.SentryOptionsS opts, string dsn)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetDsn(__arg0, dsn);
        }

        /// <summary>Gets the DSN.</summary>
        public static string SentryOptionsGetDsn(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetDsn(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>
        /// <para>Sets the sample rate, which should be a double between `0.0` and `1.0`.</para>
        /// <para>Sentry will randomly discard any event that is captured using</para>
        /// <para>`sentry_capture_event` when a sample rate&lt;&gt;1 is set.</para>
        /// </summary>
        public static void SentryOptionsSetSampleRate(global::sentry.SentryOptionsS opts, double sample_rate)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetSampleRate(__arg0, sample_rate);
        }

        /// <summary>Gets the sample rate.</summary>
        public static double SentryOptionsGetSampleRate(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetSampleRate(__arg0);
            return __ret;
        }

        /// <summary>Sets the release.</summary>
        public static void SentryOptionsSetRelease(global::sentry.SentryOptionsS opts, string release)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetRelease(__arg0, release);
        }

        /// <summary>Gets the release.</summary>
        public static string SentryOptionsGetRelease(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetRelease(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Sets the environment.</summary>
        public static void SentryOptionsSetEnvironment(global::sentry.SentryOptionsS opts, string environment)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetEnvironment(__arg0, environment);
        }

        /// <summary>Gets the environment.</summary>
        public static string SentryOptionsGetEnvironment(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetEnvironment(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Sets the dist.</summary>
        public static void SentryOptionsSetDist(global::sentry.SentryOptionsS opts, string dist)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetDist(__arg0, dist);
        }

        /// <summary>Gets the dist.</summary>
        public static string SentryOptionsGetDist(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetDist(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Configures the http proxy.</summary>
        /// <remarks>The given proxy has to include the full scheme, eg. `http://some.proxy/`.</remarks>
        public static void SentryOptionsSetHttpProxy(global::sentry.SentryOptionsS opts, string proxy)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetHttpProxy(__arg0, proxy);
        }

        /// <summary>Returns the configured http proxy.</summary>
        public static string SentryOptionsGetHttpProxy(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetHttpProxy(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>
        /// <para>Configures the path to a file containing ssl certificates for</para>
        /// <para>verification.</para>
        /// </summary>
        public static void SentryOptionsSetCaCerts(global::sentry.SentryOptionsS opts, string path)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetCaCerts(__arg0, path);
        }

        /// <summary>Returns the configured path for ca certificates.</summary>
        public static string SentryOptionsGetCaCerts(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetCaCerts(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Configures the name of the http transport thread.</summary>
        public static void SentryOptionsSetTransportThreadName(global::sentry.SentryOptionsS opts, string name)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetTransportThreadName(__arg0, name);
        }

        /// <summary>Returns the configured http transport thread name.</summary>
        public static string SentryOptionsGetTransportThreadName(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetTransportThreadName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Enables or disables debug printing mode.</summary>
        public static void SentryOptionsSetDebug(global::sentry.SentryOptionsS opts, int debug)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetDebug(__arg0, debug);
        }

        /// <summary>Returns the current value of the debug flag.</summary>
        public static int SentryOptionsGetDebug(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetDebug(__arg0);
            return __ret;
        }

        /// <summary>Enables or disables automatic session tracking.</summary>
        /// <remarks>
        /// <para>Automatic session tracking is enabled by default and is equivalent to calling</para>
        /// <para>`sentry_start_session` after startup.</para>
        /// <para>There can only be one running session, and the current session will always be</para>
        /// <para>closed implicitly by `sentry_shutdown`, when starting a new session with</para>
        /// <para>`sentry_start_session`, or manually by calling `sentry_end_session`.</para>
        /// </remarks>
        public static void SentryOptionsSetAutoSessionTracking(global::sentry.SentryOptionsS opts, int val)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetAutoSessionTracking(__arg0, val);
        }

        /// <summary>Returns true if automatic session tracking is enabled.</summary>
        public static int SentryOptionsGetAutoSessionTracking(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetAutoSessionTracking(__arg0);
            return __ret;
        }

        /// <summary>Enables or disables user consent requirements for uploads.</summary>
        /// <remarks>
        /// <para>This disables uploads until the user has given the consent to the SDK.</para>
        /// <para>Consent itself is given with `sentry_user_consent_give` and</para>
        /// <para>`sentry_user_consent_revoke`.</para>
        /// </remarks>
        public static void SentryOptionsSetRequireUserConsent(global::sentry.SentryOptionsS opts, int val)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetRequireUserConsent(__arg0, val);
        }

        /// <summary>Returns true if user consent is required.</summary>
        public static int SentryOptionsGetRequireUserConsent(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetRequireUserConsent(__arg0);
            return __ret;
        }

        /// <summary>Enables or disables on-device symbolication of stack traces.</summary>
        /// <remarks>
        /// <para>This feature can have a performance impact, and is enabled by default on</para>
        /// <para>Android. It is usually only needed when it is not possible to provide debug</para>
        /// <para>information files for system libraries which are needed for serverside</para>
        /// <para>symbolication.</para>
        /// </remarks>
        public static void SentryOptionsSetSymbolizeStacktraces(global::sentry.SentryOptionsS opts, int val)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetSymbolizeStacktraces(__arg0, val);
        }

        /// <summary>Returns true if on-device symbolication of stack traces is enabled.</summary>
        public static int SentryOptionsGetSymbolizeStacktraces(global::sentry.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetSymbolizeStacktraces(__arg0);
            return __ret;
        }

        /// <summary>Adds a new attachment to be sent along.</summary>
        /// <remarks>
        /// <para>`path` is assumed to be in platform-specific filesystem path encoding.</para>
        /// <para>API Users on windows are encouraged to use `sentry_options_add_attachmentw`</para>
        /// <para>instead.</para>
        /// </remarks>
        public static void SentryOptionsAddAttachment(global::sentry.SentryOptionsS opts, string path)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsAddAttachment(__arg0, path);
        }

        /// <summary>Sets the path to the crashpad handler if the crashpad backend is used.</summary>
        /// <remarks>
        /// <para>The path defaults to the `crashpad_handler`/`crashpad_handler.exe`</para>
        /// <para>executable, depending on platform, which is expected to be present in the</para>
        /// <para>same directory as the app executable.</para>
        /// <para>It is recommended that library users set an explicit handler path, depending</para>
        /// <para>on the directory/executable structure of their app.</para>
        /// <para>`path` is assumed to be in platform-specific filesystem path encoding.</para>
        /// <para>API Users on windows are encouraged to use `sentry_options_set_handler_pathw`</para>
        /// <para>instead.</para>
        /// </remarks>
        public static void SentryOptionsSetHandlerPath(global::sentry.SentryOptionsS opts, string path)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetHandlerPath(__arg0, path);
        }

        /// <summary>Sets the path to the Sentry Database Directory.</summary>
        /// <remarks>
        /// <para>Sentry will use this path to persist user consent, sessions, and other</para>
        /// <para>artifacts in case of a crash. This will also be used by the crashpad backend</para>
        /// <para>if it is configured.</para>
        /// <para>The directory is used for &quot;cached&quot; data, which needs to persist across</para>
        /// <para>application restarts to ensure proper flagging of release-health sessions,</para>
        /// <para>but might otherwise be safely purged regularly.</para>
        /// <para>It is roughly equivalent to the type of `AppData/Local` on Windows and</para>
        /// <para>`XDG_CACHE_HOME` on Linux, and equivalent runtime directories on other</para>
        /// <para>platforms.</para>
        /// <para>It is recommended that users set an explicit absolute path, depending</para>
        /// <para>on their apps runtime directory. The path will be created if it does not</para>
        /// <para>exist, and will be resolved to an absolute path inside of `sentry_init`. The</para>
        /// <para>directory should not be shared with other application data/configuration, as</para>
        /// <para>sentry-native will enumerate and possibly delete files in that directory. An</para>
        /// <para>example might be `$XDG_CACHE_HOME/your-app/sentry`</para>
        /// <para>If no explicit path it set, sentry-native will default to `.sentry-native` in</para>
        /// <para>the current working directory, with no specific platform-specific handling.</para>
        /// <para>`path` is assumed to be in platform-specific filesystem path encoding.</para>
        /// <para>API Users on windows are encouraged to use</para>
        /// <para>`sentry_options_set_database_pathw` instead.</para>
        /// </remarks>
        public static void SentryOptionsSetDatabasePath(global::sentry.SentryOptionsS opts, string path)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetDatabasePath(__arg0, path);
        }

        /// <summary>Enables forwarding to the system crash reporter. Disabled by default.</summary>
        /// <remarks>
        /// <para>This setting only has an effect when using Crashpad on macOS. If enabled,</para>
        /// <para>Crashpad forwards crashes to the macOS system crash reporter. Depending</para>
        /// <para>on the crash, this may impact the crash time. Even if enabled, Crashpad</para>
        /// <para>may choose not to forward certain crashes.</para>
        /// </remarks>
        public static void SentryOptionsSetSystemCrashReporterEnabled(global::sentry.SentryOptionsS opts, int enabled)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetSystemCrashReporterEnabled(__arg0, enabled);
        }

        /// <summary>Initializes the Sentry SDK with the specified options.</summary>
        /// <remarks>
        /// <para>This takes ownership of the options.  After the options have been set</para>
        /// <para>they cannot be modified any more.</para>
        /// <para>Depending on the configured transport and backend, this function might not be</para>
        /// <para>fully thread-safe.</para>
        /// <para>Returns 0 on success.</para>
        /// </remarks>
        public static int SentryInit(global::sentry.SentryOptionsS options)
        {
            var __arg0 = options is null ? __IntPtr.Zero : options.__Instance;
            var __ret = __Internal.SentryInit(__arg0);
            return __ret;
        }

        /// <summary>Shuts down the sentry client and forces transports to flush out.</summary>
        /// <remarks>Returns 0 on success.</remarks>
        public static int SentryShutdown()
        {
            var __ret = __Internal.SentryShutdown();
            return __ret;
        }

        /// <summary>This will lazily load and cache a list of all the loaded libraries.</summary>
        /// <remarks>
        /// <para>Returns a new reference to an immutable, frozen list.</para>
        /// <para>The reference must be released with `sentry_value_decref`.</para>
        /// </remarks>
        public static global::sentry.SentryValueU SentryGetModulesList()
        {
            var __ret = __Internal.SentryGetModulesList();
            return global::sentry.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Clears the internal module cache.</summary>
        /// <remarks>
        /// <para>For performance reasons, sentry will cache the list of loaded libraries when</para>
        /// <para>capturing events. This cache can get out-of-date when loading or unloading</para>
        /// <para>libraries at runtime. It is therefore recommended to call</para>
        /// <para>`sentry_clear_modulecache` when doing so, to make sure that the next call to</para>
        /// <para>`sentry_capture_event` will have an up-to-date module list.</para>
        /// </remarks>
        public static void SentryClearModulecache()
        {
            __Internal.SentryClearModulecache();
        }

        /// <summary>Gives user consent.</summary>
        public static void SentryUserConsentGive()
        {
            __Internal.SentryUserConsentGive();
        }

        /// <summary>Revokes user consent.</summary>
        public static void SentryUserConsentRevoke()
        {
            __Internal.SentryUserConsentRevoke();
        }

        /// <summary>Resets the user consent (back to unknown).</summary>
        public static void SentryUserConsentReset()
        {
            __Internal.SentryUserConsentReset();
        }

        /// <summary>Checks the current state of user consent.</summary>
        public static global::sentry.SentryUserConsentT SentryUserConsentGet()
        {
            var __ret = __Internal.SentryUserConsentGet();
            return __ret;
        }

        /// <summary>Sends a sentry event.</summary>
        public static global::sentry.SentryUuidS SentryCaptureEvent(global::sentry.SentryValueU @event)
        {
            var __arg0 = @event.__Instance;
            var __ret = new global::sentry.SentryUuidS.__Internal();
            __Internal.SentryCaptureEvent(new IntPtr(&__ret), __arg0);
            return global::sentry.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Captures an exception to be handled by the backend.</summary>
        /// <remarks>This is safe to be called from a crashing thread and may not return.</remarks>
        public static void SentryHandleException(global::sentry.SentryUcontextS uctx)
        {
            var __arg0 = uctx is null ? __IntPtr.Zero : uctx.__Instance;
            __Internal.SentryHandleException(__arg0);
        }

        /// <summary>Adds the breadcrumb to be sent in case of an event.</summary>
        public static void SentryAddBreadcrumb(global::sentry.SentryValueU breadcrumb)
        {
            var __arg0 = breadcrumb.__Instance;
            __Internal.SentryAddBreadcrumb(__arg0);
        }

        /// <summary>Sets the specified user.</summary>
        public static void SentrySetUser(global::sentry.SentryValueU user)
        {
            var __arg0 = user.__Instance;
            __Internal.SentrySetUser(__arg0);
        }

        /// <summary>Removes a user.</summary>
        public static void SentryRemoveUser()
        {
            __Internal.SentryRemoveUser();
        }

        /// <summary>Sets a tag.</summary>
        public static void SentrySetTag(string key, string value)
        {
            __Internal.SentrySetTag(key, value);
        }

        /// <summary>Removes the tag with the specified key.</summary>
        public static void SentryRemoveTag(string key)
        {
            __Internal.SentryRemoveTag(key);
        }

        /// <summary>Sets extra information.</summary>
        public static void SentrySetExtra(string key, global::sentry.SentryValueU value)
        {
            var __arg1 = value.__Instance;
            __Internal.SentrySetExtra(key, __arg1);
        }

        /// <summary>Removes the extra with the specified key.</summary>
        public static void SentryRemoveExtra(string key)
        {
            __Internal.SentryRemoveExtra(key);
        }

        /// <summary>Sets a context object.</summary>
        public static void SentrySetContext(string key, global::sentry.SentryValueU value)
        {
            var __arg1 = value.__Instance;
            __Internal.SentrySetContext(key, __arg1);
        }

        /// <summary>Removes the context object with the specified key.</summary>
        public static void SentryRemoveContext(string key)
        {
            __Internal.SentryRemoveContext(key);
        }

        /// <summary>Sets the event fingerprint.</summary>
        /// <remarks>
        /// <para>This accepts a variable number of arguments, and needs to be terminated by a</para>
        /// <para>trailing `NULL`.</para>
        /// </remarks>
        public static void SentrySetFingerprint(string fingerprint)
        {
            __Internal.SentrySetFingerprint(fingerprint);
        }

        /// <summary>Removes the fingerprint.</summary>
        public static void SentryRemoveFingerprint()
        {
            __Internal.SentryRemoveFingerprint();
        }

        /// <summary>Sets the transaction.</summary>
        public static void SentrySetTransaction(string transaction)
        {
            __Internal.SentrySetTransaction(transaction);
        }

        /// <summary>Removes the transaction.</summary>
        public static void SentryRemoveTransaction()
        {
            __Internal.SentryRemoveTransaction();
        }

        /// <summary>Sets the event level.</summary>
        public static void SentrySetLevel(global::sentry.SentryLevelE level)
        {
            __Internal.SentrySetLevel(level);
        }

        /// <summary>Starts a new session.</summary>
        public static void SentryStartSession()
        {
            __Internal.SentryStartSession();
        }

        /// <summary>Ends a session.</summary>
        public static void SentryEndSession()
        {
            __Internal.SentryEndSession();
        }

        public static string[] SysSigname
        {
            get
            {
                var __ptr = (__IntPtr*)global::sentry.__Symbols.sentry._sys_signame;
                string[] __value = null;
                if (__ptr != null)
                {
                    __value = new string[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = __ptr[i];
                }
                return __value;
            }
        }

        public static string[] SysSiglist
        {
            get
            {
                var __ptr = (__IntPtr*)global::sentry.__Symbols.sentry._sys_siglist;
                string[] __value = null;
                if (__ptr != null)
                {
                    __value = new string[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = __ptr[i];
                }
                return __value;
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_sentry_sigval___Internal(global::sentry.Sigval.__Internal __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int(int __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int___IntPtr___IntPtr(int __0, __IntPtr __1, __IntPtr __2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int_int___IntPtr___IntPtr(__IntPtr __0, int __1, int __2, __IntPtr __3, __IntPtr __4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr envelope, __IntPtr state);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr(__IntPtr options, __IntPtr state);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_ulong___IntPtr(ulong timeout, __IntPtr state);
    }
}
namespace sentry.__Symbols
{
    internal class sentry
    {
        public static IntPtr _sys_signame { get; }
        public static IntPtr _sys_siglist { get; }
        static sentry()
        {
            var path = "sentry";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new System.DllNotFoundException(path);
            _sys_signame = CppSharp.SymbolResolver.ResolveSymbol(image, "sys_signame");
            _sys_siglist = CppSharp.SymbolResolver.ResolveSymbol(image, "sys_siglist");
        }
    }
}

