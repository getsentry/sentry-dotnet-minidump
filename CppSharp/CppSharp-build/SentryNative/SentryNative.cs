// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Sentry.Native
{
    /// <summary>Type of a sentry value.</summary>
    // DEBUG: enum {
    // DEBUG:     SENTRY_VALUE_TYPE_NULL,
    // DEBUG:     SENTRY_VALUE_TYPE_BOOL,
    // DEBUG:     SENTRY_VALUE_TYPE_INT32,
    // DEBUG:     SENTRY_VALUE_TYPE_DOUBLE,
    // DEBUG:     SENTRY_VALUE_TYPE_STRING,
    // DEBUG:     SENTRY_VALUE_TYPE_LIST,
    // DEBUG:     SENTRY_VALUE_TYPE_OBJECT,
    // DEBUG: }
    public enum SentryValueTypeT : uint
    {
        SENTRY_VALUE_TYPE_NULL = 0,
        SENTRY_VALUE_TYPE_BOOL = 1,
        SENTRY_VALUE_TYPE_INT32 = 2,
        SENTRY_VALUE_TYPE_DOUBLE = 3,
        SENTRY_VALUE_TYPE_STRING = 4,
        SENTRY_VALUE_TYPE_LIST = 5,
        SENTRY_VALUE_TYPE_OBJECT = 6
    }

    /// <summary>Sentry levels for events and breadcrumbs.</summary>
    // DEBUG: enum sentry_level_e {
    // DEBUG:     SENTRY_LEVEL_DEBUG = -1,
    // DEBUG:     SENTRY_LEVEL_INFO = 0,
    // DEBUG:     SENTRY_LEVEL_WARNING = 1,
    // DEBUG:     SENTRY_LEVEL_ERROR = 2,
    // DEBUG:     SENTRY_LEVEL_FATAL = 3,
    // DEBUG: }
    public enum SentryLevelE
    {
        SENTRY_LEVEL_DEBUG = -1,
        SENTRY_LEVEL_INFO = 0,
        SENTRY_LEVEL_WARNING = 1,
        SENTRY_LEVEL_ERROR = 2,
        SENTRY_LEVEL_FATAL = 3
    }

    /// <summary>The state of user consent.</summary>
    // DEBUG: enum {
    // DEBUG:     SENTRY_USER_CONSENT_UNKNOWN = -1,
    // DEBUG:     SENTRY_USER_CONSENT_GIVEN = 1,
    // DEBUG:     SENTRY_USER_CONSENT_REVOKED = 0,
    // DEBUG: }
    public enum SentryUserConsentT
    {
        SENTRY_USER_CONSENT_UNKNOWN = -1,
        SENTRY_USER_CONSENT_GIVEN = 1,
        SENTRY_USER_CONSENT_REVOKED = 0
    }

    // DEBUG: typedef __signed char           __int8_t
    // DEBUG: typedef unsigned char           __uint8_t
    // DEBUG: typedef short                   __int16_t
    // DEBUG: typedef unsigned short          __uint16_t
    // DEBUG: typedef int                     __int32_t
    // DEBUG: typedef unsigned int            __uint32_t
    // DEBUG: typedef long long               __int64_t
    // DEBUG: typedef unsigned long long      __uint64_t
    // DEBUG: typedef long                    __darwin_intptr_t
    // DEBUG: typedef unsigned int            __darwin_natural_t
    // DEBUG: typedef int                     __darwin_ct_rune_t
    // DEBUG: typedef union {
    // DEBUG: 	char            __mbstate8[128];
    // DEBUG: 	long long       _mbstateL;                      /* for alignment */
    // DEBUG: } __mbstate_t
    // DEBUG: typedef __mbstate_t             __darwin_mbstate_t
    // DEBUG: typedef __PTRDIFF_TYPE__        __darwin_ptrdiff_t
    // DEBUG: typedef __SIZE_TYPE__           __darwin_size_t
    // DEBUG: typedef __builtin_va_list       __darwin_va_list
    // DEBUG: typedef __WCHAR_TYPE__          __darwin_wchar_t
    // DEBUG: typedef __darwin_wchar_t        __darwin_rune_t
    // DEBUG: typedef __WINT_TYPE__           __darwin_wint_t
    // DEBUG: typedef unsigned long           __darwin_clock_t
    // DEBUG: typedef __uint32_t              __darwin_socklen_t
    // DEBUG: typedef long                    __darwin_ssize_t
    // DEBUG: typedef long                    __darwin_time_t
    // DEBUG: typedef __int64_t       __darwin_blkcnt_t
    // DEBUG: typedef __int32_t       __darwin_blksize_t
    // DEBUG: typedef __int32_t       __darwin_dev_t
    // DEBUG: typedef unsigned int    __darwin_fsblkcnt_t
    // DEBUG: typedef unsigned int    __darwin_fsfilcnt_t
    // DEBUG: typedef __uint32_t      __darwin_gid_t
    // DEBUG: typedef __uint32_t      __darwin_id_t
    // DEBUG: typedef __uint64_t      __darwin_ino64_t
    // DEBUG: typedef __darwin_ino64_t __darwin_ino_t
    // DEBUG: typedef __darwin_natural_t __darwin_mach_port_name_t
    // DEBUG: typedef __darwin_mach_port_name_t __darwin_mach_port_t
    // DEBUG: typedef __uint16_t      __darwin_mode_t
    // DEBUG: typedef __int64_t       __darwin_off_t
    // DEBUG: typedef __int32_t       __darwin_pid_t
    // DEBUG: typedef __uint32_t      __darwin_sigset_t
    // DEBUG: typedef __int32_t       __darwin_suseconds_t
    // DEBUG: typedef __uint32_t      __darwin_uid_t
    // DEBUG: typedef __uint32_t      __darwin_useconds_t
    // DEBUG: typedef unsigned char   __darwin_uuid_t[16]
    // DEBUG: typedef char    __darwin_uuid_string_t[37]
    // DEBUG: typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t
    // DEBUG: typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t
    // DEBUG: typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t
    // DEBUG: typedef unsigned long __darwin_pthread_key_t
    // DEBUG: typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t
    // DEBUG: typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t
    // DEBUG: typedef struct _opaque_pthread_once_t __darwin_pthread_once_t
    // DEBUG: typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t
    // DEBUG: typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t
    // DEBUG: typedef struct _opaque_pthread_t *__darwin_pthread_t
    // DEBUG: typedef	int		__darwin_nl_item
    // DEBUG: typedef	int		__darwin_wctrans_t
    // DEBUG: typedef	__uint32_t	__darwin_wctype_t
    // DEBUG: typedef signed char           int8_t
    // DEBUG: typedef short                   int16_t
    // DEBUG: typedef int                     int32_t
    // DEBUG: typedef long long               int64_t
    // DEBUG: typedef unsigned char uint8_t
    // DEBUG: typedef unsigned short uint16_t
    // DEBUG: typedef unsigned int uint32_t
    // DEBUG: typedef unsigned long long uint64_t
    // DEBUG: typedef int8_t           int_least8_t
    // DEBUG: typedef int16_t         int_least16_t
    // DEBUG: typedef int32_t         int_least32_t
    // DEBUG: typedef int64_t         int_least64_t
    // DEBUG: typedef uint8_t         uint_least8_t
    // DEBUG: typedef uint16_t       uint_least16_t
    // DEBUG: typedef uint32_t       uint_least32_t
    // DEBUG: typedef uint64_t       uint_least64_t
    // DEBUG: typedef int8_t            int_fast8_t
    // DEBUG: typedef int16_t          int_fast16_t
    // DEBUG: typedef int32_t          int_fast32_t
    // DEBUG: typedef int64_t          int_fast64_t
    // DEBUG: typedef uint8_t          uint_fast8_t
    // DEBUG: typedef uint16_t        uint_fast16_t
    // DEBUG: typedef uint32_t        uint_fast32_t
    // DEBUG: typedef uint64_t        uint_fast64_t
    // DEBUG: typedef unsigned char           u_int8_t
    // DEBUG: typedef unsigned short                  u_int16_t
    // DEBUG: typedef unsigned int            u_int32_t
    // DEBUG: typedef unsigned long long      u_int64_t
    // DEBUG: typedef int64_t                 register_t
    // DEBUG: typedef unsigned long           uintptr_t
    // DEBUG: typedef u_int64_t               user_addr_t
    // DEBUG: typedef u_int64_t               user_size_t
    // DEBUG: typedef int64_t                 user_ssize_t
    // DEBUG: typedef int64_t                 user_long_t
    // DEBUG: typedef u_int64_t               user_ulong_t
    // DEBUG: typedef int64_t                 user_time_t
    // DEBUG: typedef int64_t                 user_off_t
    // DEBUG: typedef u_int64_t               syscall_arg_t
    // DEBUG: typedef __darwin_intptr_t       intptr_t
    // DEBUG: typedef __INTMAX_TYPE__ intmax_t
    // DEBUG: typedef __UINTMAX_TYPE__ uintmax_t
    // DEBUG: typedef __builtin_va_list va_list
    // DEBUG: typedef __builtin_va_list __gnuc_va_list
    // DEBUG: typedef __PTRDIFF_TYPE__ ptrdiff_t
    // DEBUG: typedef __SIZE_TYPE__ size_t
    // DEBUG: typedef __SIZE_TYPE__ rsize_t
    // DEBUG: typedef int sig_atomic_t
    // DEBUG: typedef _STRUCT_FP_CONTROL	__darwin_fp_control_t
    // DEBUG: typedef _STRUCT_FP_STATUS	__darwin_fp_status_t
    // DEBUG: typedef _STRUCT_MCONTEXT64      *mcontext_t
    // DEBUG: typedef __darwin_pthread_attr_t pthread_attr_t
    // DEBUG: typedef _STRUCT_SIGALTSTACK     stack_t
    // DEBUG: typedef _STRUCT_UCONTEXT        ucontext_t
    // DEBUG: typedef __darwin_pid_t        pid_t
    // DEBUG: typedef __darwin_sigset_t               sigset_t
    // DEBUG: typedef __darwin_uid_t        uid_t
    // DEBUG: typedef struct __siginfo {
    // DEBUG: 	int     si_signo;               /* signal number */
    // DEBUG: 	int     si_errno;               /* errno association */
    // DEBUG: 	int     si_code;                /* signal code */
    // DEBUG: 	pid_t   si_pid;                 /* sending process */
    // DEBUG: 	uid_t   si_uid;                 /* sender's ruid */
    // DEBUG: 	int     si_status;              /* exit value */
    // DEBUG: 	void    *si_addr;               /* faulting instruction */
    // DEBUG: 	union sigval si_value;          /* signal value */
    // DEBUG: 	long    si_band;                /* band event for SIGPOLL */
    // DEBUG: 	unsigned long   __pad[7];       /* Reserved for Future Use */
    // DEBUG: } siginfo_t
    // DEBUG: typedef void (*sig_t)(int)
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void SigT(int __0);

    // DEBUG: typedef __darwin_pthread_t pthread_t
    /// <summary>Type of a sentry value.</summary>
    // DEBUG: typedef enum {
    // DEBUG:     SENTRY_VALUE_TYPE_NULL,
    // DEBUG:     SENTRY_VALUE_TYPE_BOOL,
    // DEBUG:     SENTRY_VALUE_TYPE_INT32,
    // DEBUG:     SENTRY_VALUE_TYPE_DOUBLE,
    // DEBUG:     SENTRY_VALUE_TYPE_STRING,
    // DEBUG:     SENTRY_VALUE_TYPE_LIST,
    // DEBUG:     SENTRY_VALUE_TYPE_OBJECT,
    // DEBUG: } sentry_value_type_t
    // DEBUG: typedef union sentry_value_u sentry_value_t
    /// <summary>Sentry levels for events and breadcrumbs.</summary>
    // DEBUG: typedef enum sentry_level_e {
    // DEBUG:     SENTRY_LEVEL_DEBUG = -1,
    // DEBUG:     SENTRY_LEVEL_INFO = 0,
    // DEBUG:     SENTRY_LEVEL_WARNING = 1,
    // DEBUG:     SENTRY_LEVEL_ERROR = 2,
    // DEBUG:     SENTRY_LEVEL_FATAL = 3,
    // DEBUG: } sentry_level_t
    /// <summary>
    /// <para>This represents the OS dependent user context in the case of a crash, and can</para>
    /// <para>be used to manually capture a crash.</para>
    /// </summary>
    // DEBUG: typedef struct sentry_ucontext_s {
    // DEBUG: #ifdef _WIN32
    // DEBUG:     EXCEPTION_POINTERS exception_ptrs;
    // DEBUG: #else
    // DEBUG:     int signum;
    // DEBUG:     siginfo_t *siginfo;
    // DEBUG:     ucontext_t *user_context;
    // DEBUG: #endif
    // DEBUG: } sentry_ucontext_t
    /// <summary>A UUID</summary>
    // DEBUG: typedef struct sentry_uuid_s {
    // DEBUG:     char bytes[16];
    // DEBUG: } sentry_uuid_t
    /// <summary>The state of user consent.</summary>
    // DEBUG: typedef enum {
    // DEBUG:     SENTRY_USER_CONSENT_UNKNOWN = -1,
    // DEBUG:     SENTRY_USER_CONSENT_GIVEN = 1,
    // DEBUG:     SENTRY_USER_CONSENT_REVOKED = 0,
    // DEBUG: } sentry_user_consent_t
    /// <summary>Type of the `before_send` callback.</summary>
    /// <remarks>
    /// <para>The callback takes ownership of the `event`, and should usually return that</para>
    /// <para>same event. In case the event should be discarded, the callback needs to</para>
    /// <para>call `sentry_value_decref` on the provided event, and return a</para>
    /// <para>`sentry_value_new_null()` instead.</para>
    /// <para>This function may be invoked inside of a signal handler and must be safe for</para>
    /// <para>that purpose, see https://man7.org/linux/man-pages/man7/signal-safety.7.html.</para>
    /// </remarks>
    // DEBUG: typedef sentry_value_t (*sentry_event_function_t)(
    // DEBUG:     sentry_value_t event, void *hint, void *closure)
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Sentry.Native.SentryValueU.__Internal SentryEventFunctionT(global::Sentry.Native.SentryValueU.__Internal @event, __IntPtr hint, __IntPtr closure);

    // DEBUG: union {
    // DEBUG: 	char            __mbstate8[128];
    // DEBUG: 	long long       _mbstateL;                      /* for alignment */
    // DEBUG: }
    public unsafe partial struct MbstateT
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed sbyte __mbstate8[128];

            [FieldOffset(0)]
            internal long _mbstateL;
        }

        private MbstateT.__Internal __instance;
        internal MbstateT.__Internal __Instance { get { return __instance; } }

        internal static MbstateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MbstateT(native.ToPointer(), skipVTables);
        }

        internal static MbstateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MbstateT(native, skipVTables);
        }

        private MbstateT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private MbstateT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Sentry.Native.MbstateT.__Internal*) native;
        }

        public sbyte[] Mbstate8
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.__mbstate8)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 128);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.__mbstate8)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 128; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public long MbstateL
        {
            get
            {
                return __instance._mbstateL;
            }

            set
            {
                __instance._mbstateL = value;
            }
        }
    }

    /// <summary>A Sentry Envelope.</summary>
    /// <remarks>
    /// <para>The Envelope is an abstract type which represents a payload being sent to</para>
    /// <para>sentry. It can contain one or more items, typically an Event.</para>
    /// <para>See https://develop.sentry.dev/sdk/envelopes/</para>
    /// </remarks>
    // DEBUG: struct sentry_envelope_s
    public unsafe partial class SentryEnvelopeS
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryEnvelopeS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryEnvelopeS>();

        protected bool __ownsNativeInstance;

        internal static SentryEnvelopeS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryEnvelopeS(native.ToPointer(), skipVTables);
        }

        internal static SentryEnvelopeS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryEnvelopeS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryEnvelopeS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryEnvelopeS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryEnvelopeS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryEnvelopeS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>The Sentry Client Options.</summary>
    /// <remarks>See https://docs.sentry.io/error-reporting/configuration/</remarks>
    // DEBUG: struct sentry_options_s
    public unsafe partial class SentryOptionsS
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryOptionsS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryOptionsS>();

        protected bool __ownsNativeInstance;

        internal static SentryOptionsS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryOptionsS(native.ToPointer(), skipVTables);
        }

        internal static SentryOptionsS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryOptionsS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryOptionsS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryOptionsS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryOptionsS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryOptionsS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>This represents an interface for user-defined transports.</summary>
    /// <remarks>
    /// <para>Transports are responsible for sending envelopes to sentry and are the last</para>
    /// <para>step in the event pipeline.</para>
    /// <para>Envelopes will be submitted to the transport in a _fire and forget_ fashion,</para>
    /// <para>and the transport must send those envelopes _in order_.</para>
    /// <para>A transport has the following hooks, all of which</para>
    /// <para>take the user provided `state` as last parameter. The transport state needs</para>
    /// <para>to be set with `sentry_transport_set_state` and typically holds handles and</para>
    /// <para>other information that can be reused across requests.</para>
    /// <para>* `send_func`: This function will take ownership of an envelope, and is</para>
    /// <para>responsible for freeing it via `sentry_envelope_free`.</para>
    /// <para>* `startup_func`: This hook will be called by sentry inside of `sentry_init`</para>
    /// <para>and instructs the transport to initialize itself. Failures will bubble up</para>
    /// <para>to `sentry_init`.</para>
    /// <para>* `shutdown_func`: Instructs the transport to flush its queue and shut down.</para>
    /// <para>This hook receives a millisecond-resolution `timeout` parameter and should</para>
    /// <para>return `true` when the transport was flushed and shut down successfully.</para>
    /// <para>In case of `false`, sentry will log an error, but continue with freeing the</para>
    /// <para>transport.</para>
    /// <para>* `free_func`: Frees the transports `state`. This hook might be called even</para>
    /// <para>though `shudown_func` returned `false` previously.</para>
    /// <para>The transport interface might be extended in the future with hooks to flush</para>
    /// <para>its internal queue without shutting down, and to dump its internal queue to</para>
    /// <para>disk in case of a hard crash.</para>
    /// </remarks>
    // DEBUG: struct sentry_transport_s
    public unsafe partial class SentryTransportS
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryTransportS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryTransportS>();

        protected bool __ownsNativeInstance;

        internal static SentryTransportS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryTransportS(native.ToPointer(), skipVTables);
        }

        internal static SentryTransportS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryTransportS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryTransportS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryTransportS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryTransportS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryTransportS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    // DEBUG: struct __darwin_pthread_handler_rec {
    // DEBUG: 	void (*__routine)(void *);	// Routine to call
    // DEBUG: 	void *__arg;			// Argument to pass
    // DEBUG: 	struct __darwin_pthread_handler_rec *__next;
    // DEBUG: }
    public unsafe partial class DarwinPthreadHandlerRec : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr __routine;
            internal __IntPtr __arg;
            internal __IntPtr __next;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinPthreadHandlerRec> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinPthreadHandlerRec>();

        protected bool __ownsNativeInstance;

        internal static DarwinPthreadHandlerRec __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinPthreadHandlerRec(native.ToPointer(), skipVTables);
        }

        internal static DarwinPthreadHandlerRec __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinPthreadHandlerRec)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinPthreadHandlerRec __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinPthreadHandlerRec(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinPthreadHandlerRec(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinPthreadHandlerRec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.Delegates.Action___IntPtr Routine
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->__routine;
                return __ptr0 == IntPtr.Zero? null : (global::Sentry.Native.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sentry.Native.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->__routine = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr Arg
        {
            get
            {
                return ((__Internal*)__Instance)->__arg;
            }

            set
            {
                ((__Internal*)__Instance)->__arg = (__IntPtr) value;
            }
        }

        public global::Sentry.Native.DarwinPthreadHandlerRec Next
        {
            get
            {
                var __result0 = global::Sentry.Native.DarwinPthreadHandlerRec.__GetOrCreateInstance(((__Internal*)__Instance)->__next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->__next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    // DEBUG: struct _opaque_pthread_attr_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	char __opaque[__PTHREAD_ATTR_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadAttrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal long __sig;
            internal fixed sbyte __opaque[56];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadAttrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadAttrT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadAttrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadAttrT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadAttrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadAttrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadAttrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadAttrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadAttrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadAttrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 56);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 56; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: struct _opaque_pthread_cond_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	char __opaque[__PTHREAD_COND_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadCondT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal long __sig;
            internal fixed sbyte __opaque[40];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadCondT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadCondT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadCondT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadCondT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadCondT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadCondT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadCondT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadCondT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadCondT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadCondT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 40);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 40; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: struct _opaque_pthread_condattr_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	char __opaque[__PTHREAD_CONDATTR_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadCondattrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal long __sig;
            internal fixed sbyte __opaque[8];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadCondattrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadCondattrT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadCondattrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadCondattrT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadCondattrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadCondattrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadCondattrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadCondattrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadCondattrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadCondattrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: struct _opaque_pthread_mutex_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	char __opaque[__PTHREAD_MUTEX_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadMutexT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal long __sig;
            internal fixed sbyte __opaque[56];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadMutexT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadMutexT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadMutexT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadMutexT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadMutexT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadMutexT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadMutexT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadMutexT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadMutexT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadMutexT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 56);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 56; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: struct _opaque_pthread_mutexattr_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	char __opaque[__PTHREAD_MUTEXATTR_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadMutexattrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal long __sig;
            internal fixed sbyte __opaque[8];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadMutexattrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadMutexattrT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadMutexattrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadMutexattrT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadMutexattrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadMutexattrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadMutexattrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadMutexattrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadMutexattrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadMutexattrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: struct _opaque_pthread_once_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	char __opaque[__PTHREAD_ONCE_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadOnceT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal long __sig;
            internal fixed sbyte __opaque[8];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadOnceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadOnceT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadOnceT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadOnceT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadOnceT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadOnceT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadOnceT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadOnceT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadOnceT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadOnceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: struct _opaque_pthread_rwlock_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	char __opaque[__PTHREAD_RWLOCK_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadRwlockT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            internal long __sig;
            internal fixed sbyte __opaque[192];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadRwlockT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadRwlockT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadRwlockT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadRwlockT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadRwlockT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadRwlockT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadRwlockT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadRwlockT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadRwlockT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadRwlockT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 192);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 192; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: struct _opaque_pthread_rwlockattr_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	char __opaque[__PTHREAD_RWLOCKATTR_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadRwlockattrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal long __sig;
            internal fixed sbyte __opaque[16];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadRwlockattrT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadRwlockattrT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadRwlockattrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadRwlockattrT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadRwlockattrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadRwlockattrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadRwlockattrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadRwlockattrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadRwlockattrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadRwlockattrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: struct _opaque_pthread_t {
    // DEBUG: 	long __sig;
    // DEBUG: 	struct __darwin_pthread_handler_rec  *__cleanup_stack;
    // DEBUG: 	char __opaque[__PTHREAD_SIZE__];
    // DEBUG: }
    public unsafe partial class OpaquePthreadT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8192)]
        public partial struct __Internal
        {
            internal long __sig;
            internal __IntPtr __cleanup_stack;
            internal fixed sbyte __opaque[8176];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.OpaquePthreadT>();

        protected bool __ownsNativeInstance;

        internal static OpaquePthreadT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new OpaquePthreadT(native.ToPointer(), skipVTables);
        }

        internal static OpaquePthreadT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (OpaquePthreadT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static OpaquePthreadT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new OpaquePthreadT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private OpaquePthreadT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OpaquePthreadT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long Sig
        {
            get
            {
                return ((__Internal*)__Instance)->__sig;
            }

            set
            {
                ((__Internal*)__Instance)->__sig = value;
            }
        }

        public global::Sentry.Native.DarwinPthreadHandlerRec CleanupStack
        {
            get
            {
                var __result0 = global::Sentry.Native.DarwinPthreadHandlerRec.__GetOrCreateInstance(((__Internal*)__Instance)->__cleanup_stack, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->__cleanup_stack = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public sbyte[] Opaque
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opaque, 8176);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8176; i++)
                        ((__Internal*)__Instance)->__opaque[i] = value[i];
                }
            }
        }
    }

    // DEBUG: _STRUCT_X86_THREAD_STATE32
    // DEBUG: {
    // DEBUG:     unsigned int	__eax;
    // DEBUG:     unsigned int	__ebx;
    // DEBUG:     unsigned int	__ecx;
    // DEBUG:     unsigned int	__edx;
    // DEBUG:     unsigned int	__edi;
    // DEBUG:     unsigned int	__esi;
    // DEBUG:     unsigned int	__ebp;
    // DEBUG:     unsigned int	__esp;
    // DEBUG:     unsigned int	__ss;
    // DEBUG:     unsigned int	__eflags;
    // DEBUG:     unsigned int	__eip;
    // DEBUG:     unsigned int	__cs;
    // DEBUG:     unsigned int	__ds;
    // DEBUG:     unsigned int	__es;
    // DEBUG:     unsigned int	__fs;
    // DEBUG:     unsigned int	__gs;
    // DEBUG: }
    public unsafe partial class DarwinI386ThreadState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal uint __eax;
            internal uint __ebx;
            internal uint __ecx;
            internal uint __edx;
            internal uint __edi;
            internal uint __esi;
            internal uint __ebp;
            internal uint __esp;
            internal uint __ss;
            internal uint __eflags;
            internal uint __eip;
            internal uint __cs;
            internal uint __ds;
            internal uint __es;
            internal uint __fs;
            internal uint __gs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386ThreadState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386ThreadState>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386ThreadState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386ThreadState(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386ThreadState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386ThreadState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386ThreadState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386ThreadState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386ThreadState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386ThreadState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Eax
        {
            get
            {
                return ((__Internal*)__Instance)->__eax;
            }

            set
            {
                ((__Internal*)__Instance)->__eax = value;
            }
        }

        public uint Ebx
        {
            get
            {
                return ((__Internal*)__Instance)->__ebx;
            }

            set
            {
                ((__Internal*)__Instance)->__ebx = value;
            }
        }

        public uint Ecx
        {
            get
            {
                return ((__Internal*)__Instance)->__ecx;
            }

            set
            {
                ((__Internal*)__Instance)->__ecx = value;
            }
        }

        public uint Edx
        {
            get
            {
                return ((__Internal*)__Instance)->__edx;
            }

            set
            {
                ((__Internal*)__Instance)->__edx = value;
            }
        }

        public uint Edi
        {
            get
            {
                return ((__Internal*)__Instance)->__edi;
            }

            set
            {
                ((__Internal*)__Instance)->__edi = value;
            }
        }

        public uint Esi
        {
            get
            {
                return ((__Internal*)__Instance)->__esi;
            }

            set
            {
                ((__Internal*)__Instance)->__esi = value;
            }
        }

        public uint Ebp
        {
            get
            {
                return ((__Internal*)__Instance)->__ebp;
            }

            set
            {
                ((__Internal*)__Instance)->__ebp = value;
            }
        }

        public uint Esp
        {
            get
            {
                return ((__Internal*)__Instance)->__esp;
            }

            set
            {
                ((__Internal*)__Instance)->__esp = value;
            }
        }

        public uint Ss
        {
            get
            {
                return ((__Internal*)__Instance)->__ss;
            }

            set
            {
                ((__Internal*)__Instance)->__ss = value;
            }
        }

        public uint Eflags
        {
            get
            {
                return ((__Internal*)__Instance)->__eflags;
            }

            set
            {
                ((__Internal*)__Instance)->__eflags = value;
            }
        }

        public uint Eip
        {
            get
            {
                return ((__Internal*)__Instance)->__eip;
            }

            set
            {
                ((__Internal*)__Instance)->__eip = value;
            }
        }

        public uint Cs
        {
            get
            {
                return ((__Internal*)__Instance)->__cs;
            }

            set
            {
                ((__Internal*)__Instance)->__cs = value;
            }
        }

        public uint Ds
        {
            get
            {
                return ((__Internal*)__Instance)->__ds;
            }

            set
            {
                ((__Internal*)__Instance)->__ds = value;
            }
        }

        public uint Es
        {
            get
            {
                return ((__Internal*)__Instance)->__es;
            }

            set
            {
                ((__Internal*)__Instance)->__es = value;
            }
        }

        public uint Fs
        {
            get
            {
                return ((__Internal*)__Instance)->__fs;
            }

            set
            {
                ((__Internal*)__Instance)->__fs = value;
            }
        }

        public uint Gs
        {
            get
            {
                return ((__Internal*)__Instance)->__gs;
            }

            set
            {
                ((__Internal*)__Instance)->__gs = value;
            }
        }
    }

    // DEBUG: _STRUCT_FP_CONTROL
    // DEBUG: {
    // DEBUG:     unsigned short		__invalid	:1,
    // DEBUG:     				__denorm	:1,
    // DEBUG: 				__zdiv		:1,
    // DEBUG: 				__ovrfl		:1,
    // DEBUG: 				__undfl		:1,
    // DEBUG: 				__precis	:1,
    // DEBUG: 						:2,
    // DEBUG: 				__pc		:2,
    // DEBUG: #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
    // DEBUG: #define FP_PREC_24B		0
    // DEBUG: #define	FP_PREC_53B		2
    // DEBUG: #define FP_PREC_64B		3
    // DEBUG: #endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */
    // DEBUG: 				__rc		:2,
    // DEBUG: #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
    // DEBUG: #define FP_RND_NEAR		0
    // DEBUG: #define FP_RND_DOWN		1
    // DEBUG: #define FP_RND_UP		2
    // DEBUG: #define FP_CHOP			3
    // DEBUG: #endif /* !_POSIX_C_SOURCE || _DARWIN_C_SOURCE */
    // DEBUG: 					/*inf*/	:1,
    // DEBUG: 						:3;
    // DEBUG: }
    public unsafe partial class DarwinFpControl : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort __invalid;

            [FieldOffset(0)]
            internal ushort __denorm;

            [FieldOffset(0)]
            internal ushort __zdiv;

            [FieldOffset(0)]
            internal ushort __ovrfl;

            [FieldOffset(0)]
            internal ushort __undfl;

            [FieldOffset(0)]
            internal ushort __precis;

            [FieldOffset(0)]
            internal ushort _0;

            [FieldOffset(1)]
            internal ushort __pc;

            [FieldOffset(1)]
            internal ushort __rc;

            [FieldOffset(1)]
            internal ushort _1;

            [FieldOffset(1)]
            internal ushort _2;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinFpControl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinFpControl>();

        protected bool __ownsNativeInstance;

        internal static DarwinFpControl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinFpControl(native.ToPointer(), skipVTables);
        }

        internal static DarwinFpControl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinFpControl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinFpControl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinFpControl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinFpControl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinFpControl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Invalid
        {
            get
            {
                return ((__Internal*)__Instance)->__invalid;
            }

            set
            {
                ((__Internal*)__Instance)->__invalid = value;
            }
        }

        public ushort Denorm
        {
            get
            {
                return ((__Internal*)__Instance)->__denorm;
            }

            set
            {
                ((__Internal*)__Instance)->__denorm = value;
            }
        }

        public ushort Zdiv
        {
            get
            {
                return ((__Internal*)__Instance)->__zdiv;
            }

            set
            {
                ((__Internal*)__Instance)->__zdiv = value;
            }
        }

        public ushort Ovrfl
        {
            get
            {
                return ((__Internal*)__Instance)->__ovrfl;
            }

            set
            {
                ((__Internal*)__Instance)->__ovrfl = value;
            }
        }

        public ushort Undfl
        {
            get
            {
                return ((__Internal*)__Instance)->__undfl;
            }

            set
            {
                ((__Internal*)__Instance)->__undfl = value;
            }
        }

        public ushort Precis
        {
            get
            {
                return ((__Internal*)__Instance)->__precis;
            }

            set
            {
                ((__Internal*)__Instance)->__precis = value;
            }
        }

        public ushort _0
        {
            get
            {
                return ((__Internal*)__Instance)->_0;
            }

            set
            {
                ((__Internal*)__Instance)->_0 = value;
            }
        }

        public ushort Pc
        {
            get
            {
                return ((__Internal*)__Instance)->__pc;
            }

            set
            {
                ((__Internal*)__Instance)->__pc = value;
            }
        }

        public ushort Rc
        {
            get
            {
                return ((__Internal*)__Instance)->__rc;
            }

            set
            {
                ((__Internal*)__Instance)->__rc = value;
            }
        }
    }

    // DEBUG: _STRUCT_FP_STATUS
    // DEBUG: {
    // DEBUG:     unsigned short		__invalid	:1,
    // DEBUG:     				__denorm	:1,
    // DEBUG: 				__zdiv		:1,
    // DEBUG: 				__ovrfl		:1,
    // DEBUG: 				__undfl		:1,
    // DEBUG: 				__precis	:1,
    // DEBUG: 				__stkflt	:1,
    // DEBUG: 				__errsumm	:1,
    // DEBUG: 				__c0		:1,
    // DEBUG: 				__c1		:1,
    // DEBUG: 				__c2		:1,
    // DEBUG: 				__tos		:3,
    // DEBUG: 				__c3		:1,
    // DEBUG: 				__busy		:1;
    // DEBUG: }
    public unsafe partial class DarwinFpStatus : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort __invalid;

            [FieldOffset(0)]
            internal ushort __denorm;

            [FieldOffset(0)]
            internal ushort __zdiv;

            [FieldOffset(0)]
            internal ushort __ovrfl;

            [FieldOffset(0)]
            internal ushort __undfl;

            [FieldOffset(0)]
            internal ushort __precis;

            [FieldOffset(0)]
            internal ushort __stkflt;

            [FieldOffset(0)]
            internal ushort __errsumm;

            [FieldOffset(1)]
            internal ushort __c0;

            [FieldOffset(1)]
            internal ushort __c1;

            [FieldOffset(1)]
            internal ushort __c2;

            [FieldOffset(1)]
            internal ushort __tos;

            [FieldOffset(1)]
            internal ushort __c3;

            [FieldOffset(1)]
            internal ushort __busy;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinFpStatus> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinFpStatus>();

        protected bool __ownsNativeInstance;

        internal static DarwinFpStatus __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinFpStatus(native.ToPointer(), skipVTables);
        }

        internal static DarwinFpStatus __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinFpStatus)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinFpStatus __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinFpStatus(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinFpStatus(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinFpStatus(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Invalid
        {
            get
            {
                return ((__Internal*)__Instance)->__invalid;
            }

            set
            {
                ((__Internal*)__Instance)->__invalid = value;
            }
        }

        public ushort Denorm
        {
            get
            {
                return ((__Internal*)__Instance)->__denorm;
            }

            set
            {
                ((__Internal*)__Instance)->__denorm = value;
            }
        }

        public ushort Zdiv
        {
            get
            {
                return ((__Internal*)__Instance)->__zdiv;
            }

            set
            {
                ((__Internal*)__Instance)->__zdiv = value;
            }
        }

        public ushort Ovrfl
        {
            get
            {
                return ((__Internal*)__Instance)->__ovrfl;
            }

            set
            {
                ((__Internal*)__Instance)->__ovrfl = value;
            }
        }

        public ushort Undfl
        {
            get
            {
                return ((__Internal*)__Instance)->__undfl;
            }

            set
            {
                ((__Internal*)__Instance)->__undfl = value;
            }
        }

        public ushort Precis
        {
            get
            {
                return ((__Internal*)__Instance)->__precis;
            }

            set
            {
                ((__Internal*)__Instance)->__precis = value;
            }
        }

        public ushort Stkflt
        {
            get
            {
                return ((__Internal*)__Instance)->__stkflt;
            }

            set
            {
                ((__Internal*)__Instance)->__stkflt = value;
            }
        }

        public ushort Errsumm
        {
            get
            {
                return ((__Internal*)__Instance)->__errsumm;
            }

            set
            {
                ((__Internal*)__Instance)->__errsumm = value;
            }
        }

        public ushort C0
        {
            get
            {
                return ((__Internal*)__Instance)->__c0;
            }

            set
            {
                ((__Internal*)__Instance)->__c0 = value;
            }
        }

        public ushort C1
        {
            get
            {
                return ((__Internal*)__Instance)->__c1;
            }

            set
            {
                ((__Internal*)__Instance)->__c1 = value;
            }
        }

        public ushort C2
        {
            get
            {
                return ((__Internal*)__Instance)->__c2;
            }

            set
            {
                ((__Internal*)__Instance)->__c2 = value;
            }
        }

        public ushort Tos
        {
            get
            {
                return ((__Internal*)__Instance)->__tos;
            }

            set
            {
                ((__Internal*)__Instance)->__tos = value;
            }
        }

        public ushort C3
        {
            get
            {
                return ((__Internal*)__Instance)->__c3;
            }

            set
            {
                ((__Internal*)__Instance)->__c3 = value;
            }
        }

        public ushort Busy
        {
            get
            {
                return ((__Internal*)__Instance)->__busy;
            }

            set
            {
                ((__Internal*)__Instance)->__busy = value;
            }
        }
    }

    // DEBUG: _STRUCT_MMST_REG
    // DEBUG: {
    // DEBUG: 	char	__mmst_reg[10];
    // DEBUG: 	char	__mmst_rsrv[6];
    // DEBUG: }
    public unsafe partial class DarwinMmstReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed sbyte __mmst_reg[10];
            internal fixed sbyte __mmst_rsrv[6];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMmstReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMmstReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinMmstReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMmstReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinMmstReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMmstReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMmstReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMmstReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMmstReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMmstReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] MmstReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__mmst_reg, 10);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 10; i++)
                        ((__Internal*)__Instance)->__mmst_reg[i] = value[i];
                }
            }
        }

        public sbyte[] MmstRsrv
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__mmst_rsrv, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->__mmst_rsrv[i] = value[i];
                }
            }
        }
    }

    // DEBUG: _STRUCT_XMM_REG
    // DEBUG: {
    // DEBUG: 	char		__xmm_reg[16];
    // DEBUG: }
    public unsafe partial class DarwinXmmReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed sbyte __xmm_reg[16];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinXmmReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinXmmReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinXmmReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinXmmReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinXmmReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinXmmReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinXmmReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinXmmReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinXmmReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinXmmReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] XmmReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__xmm_reg, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->__xmm_reg[i] = value[i];
                }
            }
        }
    }

    // DEBUG: _STRUCT_YMM_REG
    // DEBUG: {
    // DEBUG: 	char		__ymm_reg[32];
    // DEBUG: }
    public unsafe partial class DarwinYmmReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal fixed sbyte __ymm_reg[32];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinYmmReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinYmmReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinYmmReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinYmmReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinYmmReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinYmmReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinYmmReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinYmmReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinYmmReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinYmmReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] YmmReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__ymm_reg, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->__ymm_reg[i] = value[i];
                }
            }
        }
    }

    // DEBUG: _STRUCT_ZMM_REG
    // DEBUG: {
    // DEBUG: 	char		__zmm_reg[64];
    // DEBUG: }
    public unsafe partial class DarwinZmmReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal fixed sbyte __zmm_reg[64];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinZmmReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinZmmReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinZmmReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinZmmReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinZmmReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinZmmReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinZmmReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinZmmReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinZmmReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinZmmReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] ZmmReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__zmm_reg, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__zmm_reg[i] = value[i];
                }
            }
        }
    }

    // DEBUG: _STRUCT_OPMASK_REG
    // DEBUG: {
    // DEBUG: 	char		__opmask_reg[8];
    // DEBUG: }
    public unsafe partial class DarwinOpmaskReg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal fixed sbyte __opmask_reg[8];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinOpmaskReg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinOpmaskReg>();

        protected bool __ownsNativeInstance;

        internal static DarwinOpmaskReg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinOpmaskReg(native.ToPointer(), skipVTables);
        }

        internal static DarwinOpmaskReg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinOpmaskReg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinOpmaskReg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinOpmaskReg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinOpmaskReg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinOpmaskReg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] OpmaskReg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__opmask_reg, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->__opmask_reg[i] = value[i];
                }
            }
        }
    }

    // DEBUG: _STRUCT_X86_FLOAT_STATE32
    // DEBUG: {
    // DEBUG: 	int 			__fpu_reserved[2];
    // DEBUG: 	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
    // DEBUG: 	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
    // DEBUG: 	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
    // DEBUG: 	__uint8_t		__fpu_rsrv1;		/* reserved */ 
    // DEBUG: 	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
    // DEBUG: 	__uint32_t		__fpu_ip;		/* x87 FPU Instruction Pointer offset */
    // DEBUG: 	__uint16_t		__fpu_cs;		/* x87 FPU Instruction Pointer Selector */
    // DEBUG: 	__uint16_t		__fpu_rsrv2;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_dp;		/* x87 FPU Instruction Operand(Data) Pointer offset */
    // DEBUG: 	__uint16_t		__fpu_ds;		/* x87 FPU Instruction Operand(Data) Pointer Selector */
    // DEBUG: 	__uint16_t		__fpu_rsrv3;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
    // DEBUG: 	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
    // DEBUG: 	char			__fpu_rsrv4[14*16];	/* reserved */
    // DEBUG: 	int 			__fpu_reserved1;
    // DEBUG: }
    public unsafe partial class DarwinI386FloatState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 524)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::Sentry.Native.DarwinFpControl.__Internal __fpu_fcw;
            internal global::Sentry.Native.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm7;
            internal fixed sbyte __fpu_rsrv4[224];
            internal int __fpu_reserved1;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386FloatState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386FloatState>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386FloatState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386FloatState(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386FloatState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386FloatState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386FloatState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386FloatState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386FloatState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386FloatState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinFpControl FpuFcw
        {
            get
            {
                return global::Sentry.Native.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::Sentry.Native.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::Sentry.Native.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::Sentry.Native.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 224);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 224; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_AVX_STATE32
    // DEBUG: {
    // DEBUG: 	int 			__fpu_reserved[2];
    // DEBUG: 	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
    // DEBUG: 	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
    // DEBUG: 	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
    // DEBUG: 	__uint8_t		__fpu_rsrv1;		/* reserved */ 
    // DEBUG: 	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
    // DEBUG: 	__uint32_t		__fpu_ip;		/* x87 FPU Instruction Pointer offset */
    // DEBUG: 	__uint16_t		__fpu_cs;		/* x87 FPU Instruction Pointer Selector */
    // DEBUG: 	__uint16_t		__fpu_rsrv2;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_dp;		/* x87 FPU Instruction Operand(Data) Pointer offset */
    // DEBUG: 	__uint16_t		__fpu_ds;		/* x87 FPU Instruction Operand(Data) Pointer Selector */
    // DEBUG: 	__uint16_t		__fpu_rsrv3;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
    // DEBUG: 	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
    // DEBUG: 	char			__fpu_rsrv4[14*16];	/* reserved */
    // DEBUG: 	int 			__fpu_reserved1;
    // DEBUG: 	char			__avx_reserved1[64];
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
    // DEBUG: }
    public unsafe partial class DarwinI386AvxState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 716)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::Sentry.Native.DarwinFpControl.__Internal __fpu_fcw;
            internal global::Sentry.Native.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm7;
            internal fixed sbyte __fpu_rsrv4[224];
            internal int __fpu_reserved1;
            internal fixed sbyte __avx_reserved1[64];
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh7;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386AvxState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386AvxState>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386AvxState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386AvxState(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386AvxState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386AvxState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386AvxState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386AvxState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386AvxState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386AvxState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinFpControl FpuFcw
        {
            get
            {
                return global::Sentry.Native.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::Sentry.Native.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::Sentry.Native.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::Sentry.Native.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 224);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 224; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }

        public sbyte[] AvxReserved1
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__avx_reserved1, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__avx_reserved1[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_X86_AVX512_STATE32
    // DEBUG: {
    // DEBUG: 	int 			__fpu_reserved[2];
    // DEBUG: 	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
    // DEBUG: 	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
    // DEBUG: 	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
    // DEBUG: 	__uint8_t		__fpu_rsrv1;		/* reserved */ 
    // DEBUG: 	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
    // DEBUG: 	__uint32_t		__fpu_ip;		/* x87 FPU Instruction Pointer offset */
    // DEBUG: 	__uint16_t		__fpu_cs;		/* x87 FPU Instruction Pointer Selector */
    // DEBUG: 	__uint16_t		__fpu_rsrv2;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_dp;		/* x87 FPU Instruction Operand(Data) Pointer offset */
    // DEBUG: 	__uint16_t		__fpu_ds;		/* x87 FPU Instruction Operand(Data) Pointer Selector */
    // DEBUG: 	__uint16_t		__fpu_rsrv3;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
    // DEBUG: 	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
    // DEBUG: 	char			__fpu_rsrv4[14*16];	/* reserved */
    // DEBUG: 	int 			__fpu_reserved1;
    // DEBUG: 	char			__avx_reserved1[64];
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k0;		/* K0 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k1;		/* K1 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k2;		/* K2 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k3;		/* K3 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k4;		/* K4 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k5;		/* K5 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k6;		/* K6 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k7;		/* K7 */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh0;		/* ZMMH 0  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh1;		/* ZMMH 1  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh2;		/* ZMMH 2  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh3;		/* ZMMH 3  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh4;		/* ZMMH 4  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh5;		/* ZMMH 5  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh6;		/* ZMMH 6  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh7;		/* ZMMH 7  */
    // DEBUG: }
    public unsafe partial class DarwinI386Avx512State : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1036)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::Sentry.Native.DarwinFpControl.__Internal __fpu_fcw;
            internal global::Sentry.Native.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm7;
            internal fixed sbyte __fpu_rsrv4[224];
            internal int __fpu_reserved1;
            internal fixed sbyte __avx_reserved1[64];
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh7;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k0;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k1;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k2;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k3;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k4;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k5;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k6;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k7;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh0;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh1;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh2;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh3;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh4;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh5;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh6;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh7;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386Avx512State> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386Avx512State>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386Avx512State __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386Avx512State(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386Avx512State __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386Avx512State)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386Avx512State __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386Avx512State(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386Avx512State(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386Avx512State(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinFpControl FpuFcw
        {
            get
            {
                return global::Sentry.Native.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::Sentry.Native.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::Sentry.Native.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::Sentry.Native.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 224);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 224; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }

        public sbyte[] AvxReserved1
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__avx_reserved1, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__avx_reserved1[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK0
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k0 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK1
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k1 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK2
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k2 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK3
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k3 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK4
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k4 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK5
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k5 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK6
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k6 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK7
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k7 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh0
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh0 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh1
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh1 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh2
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh2 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh3
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh3 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh4
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh4 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh5
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh5 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh6
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh6 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh7
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh7 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_X86_EXCEPTION_STATE32
    // DEBUG: {
    // DEBUG: 	__uint16_t	__trapno;
    // DEBUG: 	__uint16_t	__cpu;
    // DEBUG: 	__uint32_t	__err;
    // DEBUG: 	__uint32_t	__faultvaddr;
    // DEBUG: }
    public unsafe partial class DarwinI386ExceptionState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal ushort __trapno;
            internal ushort __cpu;
            internal uint __err;
            internal uint __faultvaddr;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386ExceptionState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinI386ExceptionState>();

        protected bool __ownsNativeInstance;

        internal static DarwinI386ExceptionState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinI386ExceptionState(native.ToPointer(), skipVTables);
        }

        internal static DarwinI386ExceptionState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinI386ExceptionState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinI386ExceptionState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinI386ExceptionState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinI386ExceptionState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinI386ExceptionState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Trapno
        {
            get
            {
                return ((__Internal*)__Instance)->__trapno;
            }

            set
            {
                ((__Internal*)__Instance)->__trapno = value;
            }
        }

        public ushort Cpu
        {
            get
            {
                return ((__Internal*)__Instance)->__cpu;
            }

            set
            {
                ((__Internal*)__Instance)->__cpu = value;
            }
        }

        public uint Err
        {
            get
            {
                return ((__Internal*)__Instance)->__err;
            }

            set
            {
                ((__Internal*)__Instance)->__err = value;
            }
        }

        public uint Faultvaddr
        {
            get
            {
                return ((__Internal*)__Instance)->__faultvaddr;
            }

            set
            {
                ((__Internal*)__Instance)->__faultvaddr = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_DEBUG_STATE32
    // DEBUG: {
    // DEBUG: 	unsigned int	__dr0;
    // DEBUG: 	unsigned int	__dr1;
    // DEBUG: 	unsigned int	__dr2;
    // DEBUG: 	unsigned int	__dr3;
    // DEBUG: 	unsigned int	__dr4;
    // DEBUG: 	unsigned int	__dr5;
    // DEBUG: 	unsigned int	__dr6;
    // DEBUG: 	unsigned int	__dr7;
    // DEBUG: }
    public unsafe partial class DarwinX86DebugState32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal uint __dr0;
            internal uint __dr1;
            internal uint __dr2;
            internal uint __dr3;
            internal uint __dr4;
            internal uint __dr5;
            internal uint __dr6;
            internal uint __dr7;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86DebugState32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86DebugState32>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86DebugState32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86DebugState32(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86DebugState32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86DebugState32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86DebugState32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86DebugState32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86DebugState32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86DebugState32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Dr0
        {
            get
            {
                return ((__Internal*)__Instance)->__dr0;
            }

            set
            {
                ((__Internal*)__Instance)->__dr0 = value;
            }
        }

        public uint Dr1
        {
            get
            {
                return ((__Internal*)__Instance)->__dr1;
            }

            set
            {
                ((__Internal*)__Instance)->__dr1 = value;
            }
        }

        public uint Dr2
        {
            get
            {
                return ((__Internal*)__Instance)->__dr2;
            }

            set
            {
                ((__Internal*)__Instance)->__dr2 = value;
            }
        }

        public uint Dr3
        {
            get
            {
                return ((__Internal*)__Instance)->__dr3;
            }

            set
            {
                ((__Internal*)__Instance)->__dr3 = value;
            }
        }

        public uint Dr4
        {
            get
            {
                return ((__Internal*)__Instance)->__dr4;
            }

            set
            {
                ((__Internal*)__Instance)->__dr4 = value;
            }
        }

        public uint Dr5
        {
            get
            {
                return ((__Internal*)__Instance)->__dr5;
            }

            set
            {
                ((__Internal*)__Instance)->__dr5 = value;
            }
        }

        public uint Dr6
        {
            get
            {
                return ((__Internal*)__Instance)->__dr6;
            }

            set
            {
                ((__Internal*)__Instance)->__dr6 = value;
            }
        }

        public uint Dr7
        {
            get
            {
                return ((__Internal*)__Instance)->__dr7;
            }

            set
            {
                ((__Internal*)__Instance)->__dr7 = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_INSTRUCTION_STATE
    // DEBUG: {
    // DEBUG:         int		__insn_stream_valid_bytes;
    // DEBUG:         int		__insn_offset;
    // DEBUG: 	int		__out_of_synch;	/*
    // DEBUG: 					 * non-zero when the cacheline that includes the insn_offset
    // DEBUG: 					 * is replaced in the insn_bytes array due to a mismatch
    // DEBUG: 					 * detected when comparing it with the same cacheline in memory
    // DEBUG: 					 */
    // DEBUG: #define _X86_INSTRUCTION_STATE_MAX_INSN_BYTES    (2448 - 64 - 4)
    // DEBUG:         __uint8_t	__insn_bytes[_X86_INSTRUCTION_STATE_MAX_INSN_BYTES];
    // DEBUG: #define _X86_INSTRUCTION_STATE_CACHELINE_SIZE	64
    // DEBUG: 	__uint8_t	__insn_cacheline[_X86_INSTRUCTION_STATE_CACHELINE_SIZE];
    // DEBUG: }
    public unsafe partial class X86InstructionState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2456)]
        public partial struct __Internal
        {
            internal int __insn_stream_valid_bytes;
            internal int __insn_offset;
            internal int __out_of_synch;
            internal fixed byte __insn_bytes[2380];
            internal fixed byte __insn_cacheline[64];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.X86InstructionState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.X86InstructionState>();

        protected bool __ownsNativeInstance;

        internal static X86InstructionState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new X86InstructionState(native.ToPointer(), skipVTables);
        }

        internal static X86InstructionState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (X86InstructionState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static X86InstructionState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new X86InstructionState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private X86InstructionState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected X86InstructionState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int InsnStreamValidBytes
        {
            get
            {
                return ((__Internal*)__Instance)->__insn_stream_valid_bytes;
            }

            set
            {
                ((__Internal*)__Instance)->__insn_stream_valid_bytes = value;
            }
        }

        public int InsnOffset
        {
            get
            {
                return ((__Internal*)__Instance)->__insn_offset;
            }

            set
            {
                ((__Internal*)__Instance)->__insn_offset = value;
            }
        }

        public int OutOfSynch
        {
            get
            {
                return ((__Internal*)__Instance)->__out_of_synch;
            }

            set
            {
                ((__Internal*)__Instance)->__out_of_synch = value;
            }
        }

        public byte[] InsnBytes
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__insn_bytes, 2380);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2380; i++)
                        ((__Internal*)__Instance)->__insn_bytes[i] = value[i];
                }
            }
        }

        public byte[] InsnCacheline
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__insn_cacheline, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__insn_cacheline[i] = value[i];
                }
            }
        }
    }

    // DEBUG: _STRUCT_LAST_BRANCH_RECORD
    // DEBUG: {
    // DEBUG: 	__uint64_t	__from_ip;
    // DEBUG: 	__uint64_t	__to_ip;
    // DEBUG: 	__uint32_t	__mispredict : 1,
    // DEBUG: 			__tsx_abort  : 1,
    // DEBUG: 			__in_tsx     : 1,
    // DEBUG: 			__cycle_count: 16,
    // DEBUG: 			__reserved   : 13;
    // DEBUG: }
    public unsafe partial class LastBranchRecord : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong __from_ip;

            [FieldOffset(8)]
            internal ulong __to_ip;

            [FieldOffset(16)]
            internal uint __mispredict;

            [FieldOffset(16)]
            internal uint __tsx_abort;

            [FieldOffset(16)]
            internal uint __in_tsx;

            [FieldOffset(16)]
            internal uint __cycle_count;

            [FieldOffset(18)]
            internal uint __reserved;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.LastBranchRecord> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.LastBranchRecord>();

        protected bool __ownsNativeInstance;

        internal static LastBranchRecord __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new LastBranchRecord(native.ToPointer(), skipVTables);
        }

        internal static LastBranchRecord __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (LastBranchRecord)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static LastBranchRecord __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LastBranchRecord(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LastBranchRecord(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LastBranchRecord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong FromIp
        {
            get
            {
                return ((__Internal*)__Instance)->__from_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__from_ip = value;
            }
        }

        public ulong ToIp
        {
            get
            {
                return ((__Internal*)__Instance)->__to_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__to_ip = value;
            }
        }

        public uint Mispredict
        {
            get
            {
                return ((__Internal*)__Instance)->__mispredict;
            }

            set
            {
                ((__Internal*)__Instance)->__mispredict = value;
            }
        }

        public uint TsxAbort
        {
            get
            {
                return ((__Internal*)__Instance)->__tsx_abort;
            }

            set
            {
                ((__Internal*)__Instance)->__tsx_abort = value;
            }
        }

        public uint InTsx
        {
            get
            {
                return ((__Internal*)__Instance)->__in_tsx;
            }

            set
            {
                ((__Internal*)__Instance)->__in_tsx = value;
            }
        }

        public uint CycleCount
        {
            get
            {
                return ((__Internal*)__Instance)->__cycle_count;
            }

            set
            {
                ((__Internal*)__Instance)->__cycle_count = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->__reserved;
            }

            set
            {
                ((__Internal*)__Instance)->__reserved = value;
            }
        }
    }

    // DEBUG: _STRUCT_LAST_BRANCH_STATE
    // DEBUG: {
    // DEBUG:         int				__lbr_count;
    // DEBUG: 	__uint32_t			__lbr_supported_tsx : 1,
    // DEBUG: 					__lbr_supported_cycle_count : 1,
    // DEBUG: 					__reserved : 30;
    // DEBUG: #define	__LASTBRANCH_MAX	32
    // DEBUG: 	_STRUCT_LAST_BRANCH_RECORD	__lbrs[__LASTBRANCH_MAX];
    // DEBUG: }
    public unsafe partial class LastBranchState : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 776)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int __lbr_count;

            [FieldOffset(4)]
            internal uint __lbr_supported_tsx;

            [FieldOffset(4)]
            internal uint __lbr_supported_cycle_count;

            [FieldOffset(4)]
            internal uint __reserved;

            [FieldOffset(8)]
            internal fixed byte __lbrs[768];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.LastBranchState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.LastBranchState>();

        protected bool __ownsNativeInstance;

        internal static LastBranchState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new LastBranchState(native.ToPointer(), skipVTables);
        }

        internal static LastBranchState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (LastBranchState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static LastBranchState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LastBranchState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LastBranchState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LastBranchState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LbrCount
        {
            get
            {
                return ((__Internal*)__Instance)->__lbr_count;
            }

            set
            {
                ((__Internal*)__Instance)->__lbr_count = value;
            }
        }

        public uint LbrSupportedTsx
        {
            get
            {
                return ((__Internal*)__Instance)->__lbr_supported_tsx;
            }

            set
            {
                ((__Internal*)__Instance)->__lbr_supported_tsx = value;
            }
        }

        public uint LbrSupportedCycleCount
        {
            get
            {
                return ((__Internal*)__Instance)->__lbr_supported_cycle_count;
            }

            set
            {
                ((__Internal*)__Instance)->__lbr_supported_cycle_count = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->__reserved;
            }

            set
            {
                ((__Internal*)__Instance)->__reserved = value;
            }
        }

        public global::Sentry.Native.LastBranchRecord[] Lbrs
        {
            get
            {
                global::Sentry.Native.LastBranchRecord[] __value = null;
                if (((__Internal*)__Instance)->__lbrs != null)
                {
                    __value = new global::Sentry.Native.LastBranchRecord[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = global::Sentry.Native.LastBranchRecord.__CreateInstance(*((global::Sentry.Native.LastBranchRecord.__Internal*)&(((__Internal*)__Instance)->__lbrs[i * sizeof(global::Sentry.Native.LastBranchRecord.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 32)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 32; i++)
                        *(global::Sentry.Native.LastBranchRecord.__Internal*) &((__Internal*)__Instance)->__lbrs[i * sizeof(global::Sentry.Native.LastBranchRecord.__Internal)] = *(global::Sentry.Native.LastBranchRecord.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    // DEBUG: _STRUCT_X86_PAGEIN_STATE
    // DEBUG: {
    // DEBUG: 	int __pagein_error;
    // DEBUG: }
    public unsafe partial class X86PageinState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal int __pagein_error;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.X86PageinState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.X86PageinState>();

        protected bool __ownsNativeInstance;

        internal static X86PageinState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new X86PageinState(native.ToPointer(), skipVTables);
        }

        internal static X86PageinState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (X86PageinState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static X86PageinState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new X86PageinState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private X86PageinState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected X86PageinState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int PageinError
        {
            get
            {
                return ((__Internal*)__Instance)->__pagein_error;
            }

            set
            {
                ((__Internal*)__Instance)->__pagein_error = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_THREAD_STATE64
    // DEBUG: {
    // DEBUG: 	__uint64_t	__rax;
    // DEBUG: 	__uint64_t	__rbx;
    // DEBUG: 	__uint64_t	__rcx;
    // DEBUG: 	__uint64_t	__rdx;
    // DEBUG: 	__uint64_t	__rdi;
    // DEBUG: 	__uint64_t	__rsi;
    // DEBUG: 	__uint64_t	__rbp;
    // DEBUG: 	__uint64_t	__rsp;
    // DEBUG: 	__uint64_t	__r8;
    // DEBUG: 	__uint64_t	__r9;
    // DEBUG: 	__uint64_t	__r10;
    // DEBUG: 	__uint64_t	__r11;
    // DEBUG: 	__uint64_t	__r12;
    // DEBUG: 	__uint64_t	__r13;
    // DEBUG: 	__uint64_t	__r14;
    // DEBUG: 	__uint64_t	__r15;
    // DEBUG: 	__uint64_t	__rip;
    // DEBUG: 	__uint64_t	__rflags;
    // DEBUG: 	__uint64_t	__cs;
    // DEBUG: 	__uint64_t	__fs;
    // DEBUG: 	__uint64_t	__gs;
    // DEBUG: }
    public unsafe partial class DarwinX86ThreadState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 168)]
        public partial struct __Internal
        {
            internal ulong __rax;
            internal ulong __rbx;
            internal ulong __rcx;
            internal ulong __rdx;
            internal ulong __rdi;
            internal ulong __rsi;
            internal ulong __rbp;
            internal ulong __rsp;
            internal ulong __r8;
            internal ulong __r9;
            internal ulong __r10;
            internal ulong __r11;
            internal ulong __r12;
            internal ulong __r13;
            internal ulong __r14;
            internal ulong __r15;
            internal ulong __rip;
            internal ulong __rflags;
            internal ulong __cs;
            internal ulong __fs;
            internal ulong __gs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86ThreadState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86ThreadState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86ThreadState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86ThreadState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86ThreadState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86ThreadState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86ThreadState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86ThreadState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86ThreadState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86ThreadState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Rax
        {
            get
            {
                return ((__Internal*)__Instance)->__rax;
            }

            set
            {
                ((__Internal*)__Instance)->__rax = value;
            }
        }

        public ulong Rbx
        {
            get
            {
                return ((__Internal*)__Instance)->__rbx;
            }

            set
            {
                ((__Internal*)__Instance)->__rbx = value;
            }
        }

        public ulong Rcx
        {
            get
            {
                return ((__Internal*)__Instance)->__rcx;
            }

            set
            {
                ((__Internal*)__Instance)->__rcx = value;
            }
        }

        public ulong Rdx
        {
            get
            {
                return ((__Internal*)__Instance)->__rdx;
            }

            set
            {
                ((__Internal*)__Instance)->__rdx = value;
            }
        }

        public ulong Rdi
        {
            get
            {
                return ((__Internal*)__Instance)->__rdi;
            }

            set
            {
                ((__Internal*)__Instance)->__rdi = value;
            }
        }

        public ulong Rsi
        {
            get
            {
                return ((__Internal*)__Instance)->__rsi;
            }

            set
            {
                ((__Internal*)__Instance)->__rsi = value;
            }
        }

        public ulong Rbp
        {
            get
            {
                return ((__Internal*)__Instance)->__rbp;
            }

            set
            {
                ((__Internal*)__Instance)->__rbp = value;
            }
        }

        public ulong Rsp
        {
            get
            {
                return ((__Internal*)__Instance)->__rsp;
            }

            set
            {
                ((__Internal*)__Instance)->__rsp = value;
            }
        }

        public ulong R8
        {
            get
            {
                return ((__Internal*)__Instance)->__r8;
            }

            set
            {
                ((__Internal*)__Instance)->__r8 = value;
            }
        }

        public ulong R9
        {
            get
            {
                return ((__Internal*)__Instance)->__r9;
            }

            set
            {
                ((__Internal*)__Instance)->__r9 = value;
            }
        }

        public ulong R10
        {
            get
            {
                return ((__Internal*)__Instance)->__r10;
            }

            set
            {
                ((__Internal*)__Instance)->__r10 = value;
            }
        }

        public ulong R11
        {
            get
            {
                return ((__Internal*)__Instance)->__r11;
            }

            set
            {
                ((__Internal*)__Instance)->__r11 = value;
            }
        }

        public ulong R12
        {
            get
            {
                return ((__Internal*)__Instance)->__r12;
            }

            set
            {
                ((__Internal*)__Instance)->__r12 = value;
            }
        }

        public ulong R13
        {
            get
            {
                return ((__Internal*)__Instance)->__r13;
            }

            set
            {
                ((__Internal*)__Instance)->__r13 = value;
            }
        }

        public ulong R14
        {
            get
            {
                return ((__Internal*)__Instance)->__r14;
            }

            set
            {
                ((__Internal*)__Instance)->__r14 = value;
            }
        }

        public ulong R15
        {
            get
            {
                return ((__Internal*)__Instance)->__r15;
            }

            set
            {
                ((__Internal*)__Instance)->__r15 = value;
            }
        }

        public ulong Rip
        {
            get
            {
                return ((__Internal*)__Instance)->__rip;
            }

            set
            {
                ((__Internal*)__Instance)->__rip = value;
            }
        }

        public ulong Rflags
        {
            get
            {
                return ((__Internal*)__Instance)->__rflags;
            }

            set
            {
                ((__Internal*)__Instance)->__rflags = value;
            }
        }

        public ulong Cs
        {
            get
            {
                return ((__Internal*)__Instance)->__cs;
            }

            set
            {
                ((__Internal*)__Instance)->__cs = value;
            }
        }

        public ulong Fs
        {
            get
            {
                return ((__Internal*)__Instance)->__fs;
            }

            set
            {
                ((__Internal*)__Instance)->__fs = value;
            }
        }

        public ulong Gs
        {
            get
            {
                return ((__Internal*)__Instance)->__gs;
            }

            set
            {
                ((__Internal*)__Instance)->__gs = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_THREAD_FULL_STATE64
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_THREAD_STATE64	__ss64;
    // DEBUG: 	__uint64_t			__ds;
    // DEBUG: 	__uint64_t			__es;
    // DEBUG: 	__uint64_t			__ss;
    // DEBUG: 	__uint64_t			__gsbase;
    // DEBUG: }
    public unsafe partial class DarwinX86ThreadFullState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinX86ThreadState64.__Internal __ss64;
            internal ulong __ds;
            internal ulong __es;
            internal ulong __ss;
            internal ulong __gsbase;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86ThreadFullState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86ThreadFullState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86ThreadFullState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86ThreadFullState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86ThreadFullState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86ThreadFullState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86ThreadFullState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86ThreadFullState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86ThreadFullState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86ThreadFullState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinX86ThreadState64 Ss64
        {
            get
            {
                return global::Sentry.Native.DarwinX86ThreadState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss64));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss64 = *(global::Sentry.Native.DarwinX86ThreadState64.__Internal*) value.__Instance;
            }
        }

        public ulong Ds
        {
            get
            {
                return ((__Internal*)__Instance)->__ds;
            }

            set
            {
                ((__Internal*)__Instance)->__ds = value;
            }
        }

        public ulong Es
        {
            get
            {
                return ((__Internal*)__Instance)->__es;
            }

            set
            {
                ((__Internal*)__Instance)->__es = value;
            }
        }

        public ulong Ss
        {
            get
            {
                return ((__Internal*)__Instance)->__ss;
            }

            set
            {
                ((__Internal*)__Instance)->__ss = value;
            }
        }

        public ulong Gsbase
        {
            get
            {
                return ((__Internal*)__Instance)->__gsbase;
            }

            set
            {
                ((__Internal*)__Instance)->__gsbase = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_FLOAT_STATE64
    // DEBUG: {
    // DEBUG: 	int 			__fpu_reserved[2];
    // DEBUG: 	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
    // DEBUG: 	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
    // DEBUG: 	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
    // DEBUG: 	__uint8_t		__fpu_rsrv1;		/* reserved */ 
    // DEBUG: 	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
    // DEBUG: 
    // DEBUG: 	/* x87 FPU Instruction Pointer */
    // DEBUG: 	__uint32_t		__fpu_ip;		/* offset */
    // DEBUG: 	__uint16_t		__fpu_cs;		/* Selector */
    // DEBUG: 
    // DEBUG: 	__uint16_t		__fpu_rsrv2;		/* reserved */
    // DEBUG: 
    // DEBUG: 	/* x87 FPU Instruction Operand(Data) Pointer */
    // DEBUG: 	__uint32_t		__fpu_dp;		/* offset */
    // DEBUG: 	__uint16_t		__fpu_ds;		/* Selector */
    // DEBUG: 
    // DEBUG: 	__uint16_t		__fpu_rsrv3;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
    // DEBUG: 	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm8;		/* XMM 8  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm9;		/* XMM 9  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm10;		/* XMM 10  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm11;		/* XMM 11 */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm12;		/* XMM 12  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm13;		/* XMM 13  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm14;		/* XMM 14  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm15;		/* XMM 15  */
    // DEBUG: 	char			__fpu_rsrv4[6*16];	/* reserved */
    // DEBUG: 	int 			__fpu_reserved1;
    // DEBUG: }
    public unsafe partial class DarwinX86FloatState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 524)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::Sentry.Native.DarwinFpControl.__Internal __fpu_fcw;
            internal global::Sentry.Native.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm8;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm9;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm10;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm11;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm12;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm13;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm14;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm15;
            internal fixed sbyte __fpu_rsrv4[96];
            internal int __fpu_reserved1;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86FloatState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86FloatState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86FloatState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86FloatState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86FloatState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86FloatState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86FloatState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86FloatState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86FloatState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86FloatState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinFpControl FpuFcw
        {
            get
            {
                return global::Sentry.Native.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::Sentry.Native.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::Sentry.Native.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::Sentry.Native.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm8
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm8 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm9
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm9 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm10
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm10 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm11
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm11 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm12
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm12 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm13
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm13 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm14
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm14 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm15
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm15 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 96);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 96; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_AVX_STATE64
    // DEBUG: {
    // DEBUG: 	int 			__fpu_reserved[2];
    // DEBUG: 	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
    // DEBUG: 	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
    // DEBUG: 	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
    // DEBUG: 	__uint8_t		__fpu_rsrv1;		/* reserved */ 
    // DEBUG: 	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
    // DEBUG: 
    // DEBUG: 	/* x87 FPU Instruction Pointer */
    // DEBUG: 	__uint32_t		__fpu_ip;		/* offset */
    // DEBUG: 	__uint16_t		__fpu_cs;		/* Selector */
    // DEBUG: 
    // DEBUG: 	__uint16_t		__fpu_rsrv2;		/* reserved */
    // DEBUG: 
    // DEBUG: 	/* x87 FPU Instruction Operand(Data) Pointer */
    // DEBUG: 	__uint32_t		__fpu_dp;		/* offset */
    // DEBUG: 	__uint16_t		__fpu_ds;		/* Selector */
    // DEBUG: 
    // DEBUG: 	__uint16_t		__fpu_rsrv3;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
    // DEBUG: 	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm8;		/* XMM 8  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm9;		/* XMM 9  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm10;		/* XMM 10  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm11;		/* XMM 11 */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm12;		/* XMM 12  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm13;		/* XMM 13  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm14;		/* XMM 14  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm15;		/* XMM 15  */
    // DEBUG: 	char			__fpu_rsrv4[6*16];	/* reserved */
    // DEBUG: 	int 			__fpu_reserved1;
    // DEBUG: 	char			__avx_reserved1[64];
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh8;		/* YMMH 8  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh9;		/* YMMH 9  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh10;		/* YMMH 10  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh11;		/* YMMH 11  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh12;		/* YMMH 12  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh13;		/* YMMH 13  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh14;		/* YMMH 14  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh15;		/* YMMH 15  */
    // DEBUG: }
    public unsafe partial class DarwinX86AvxState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 844)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::Sentry.Native.DarwinFpControl.__Internal __fpu_fcw;
            internal global::Sentry.Native.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm8;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm9;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm10;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm11;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm12;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm13;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm14;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm15;
            internal fixed sbyte __fpu_rsrv4[96];
            internal int __fpu_reserved1;
            internal fixed sbyte __avx_reserved1[64];
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh8;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh9;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh10;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh11;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh12;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh13;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh14;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh15;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86AvxState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86AvxState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86AvxState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86AvxState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86AvxState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86AvxState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86AvxState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86AvxState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86AvxState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86AvxState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinFpControl FpuFcw
        {
            get
            {
                return global::Sentry.Native.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::Sentry.Native.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::Sentry.Native.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::Sentry.Native.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm8
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm8 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm9
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm9 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm10
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm10 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm11
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm11 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm12
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm12 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm13
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm13 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm14
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm14 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm15
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm15 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 96);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 96; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }

        public sbyte[] AvxReserved1
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__avx_reserved1, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__avx_reserved1[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh8
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh8 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh9
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh9 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh10
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh10 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh11
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh11 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh12
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh12 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh13
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh13 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh14
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh14 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh15
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh15 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_X86_AVX512_STATE64
    // DEBUG: {
    // DEBUG: 	int 			__fpu_reserved[2];
    // DEBUG: 	_STRUCT_FP_CONTROL	__fpu_fcw;		/* x87 FPU control word */
    // DEBUG: 	_STRUCT_FP_STATUS	__fpu_fsw;		/* x87 FPU status word */
    // DEBUG: 	__uint8_t		__fpu_ftw;		/* x87 FPU tag word */
    // DEBUG: 	__uint8_t		__fpu_rsrv1;		/* reserved */ 
    // DEBUG: 	__uint16_t		__fpu_fop;		/* x87 FPU Opcode */
    // DEBUG: 
    // DEBUG: 	/* x87 FPU Instruction Pointer */
    // DEBUG: 	__uint32_t		__fpu_ip;		/* offset */
    // DEBUG: 	__uint16_t		__fpu_cs;		/* Selector */
    // DEBUG: 
    // DEBUG: 	__uint16_t		__fpu_rsrv2;		/* reserved */
    // DEBUG: 
    // DEBUG: 	/* x87 FPU Instruction Operand(Data) Pointer */
    // DEBUG: 	__uint32_t		__fpu_dp;		/* offset */
    // DEBUG: 	__uint16_t		__fpu_ds;		/* Selector */
    // DEBUG: 
    // DEBUG: 	__uint16_t		__fpu_rsrv3;		/* reserved */
    // DEBUG: 	__uint32_t		__fpu_mxcsr;		/* MXCSR Register state */
    // DEBUG: 	__uint32_t		__fpu_mxcsrmask;	/* MXCSR mask */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm0;		/* ST0/MM0   */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm1;		/* ST1/MM1  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm2;		/* ST2/MM2  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm3;		/* ST3/MM3  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm4;		/* ST4/MM4  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm5;		/* ST5/MM5  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm6;		/* ST6/MM6  */
    // DEBUG: 	_STRUCT_MMST_REG	__fpu_stmm7;		/* ST7/MM7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm0;		/* XMM 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm1;		/* XMM 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm2;		/* XMM 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm3;		/* XMM 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm4;		/* XMM 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm5;		/* XMM 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm6;		/* XMM 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm7;		/* XMM 7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm8;		/* XMM 8  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm9;		/* XMM 9  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm10;		/* XMM 10  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm11;		/* XMM 11 */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm12;		/* XMM 12  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm13;		/* XMM 13  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm14;		/* XMM 14  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_xmm15;		/* XMM 15  */
    // DEBUG: 	char			__fpu_rsrv4[6*16];	/* reserved */
    // DEBUG: 	int 			__fpu_reserved1;
    // DEBUG: 	char			__avx_reserved1[64];
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh0;		/* YMMH 0  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh1;		/* YMMH 1  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh2;		/* YMMH 2  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh3;		/* YMMH 3  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh4;		/* YMMH 4  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh5;		/* YMMH 5  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh6;		/* YMMH 6  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh7;		/* YMMH 7  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh8;		/* YMMH 8  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh9;		/* YMMH 9  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh10;		/* YMMH 10  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh11;		/* YMMH 11  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh12;		/* YMMH 12  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh13;		/* YMMH 13  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh14;		/* YMMH 14  */
    // DEBUG: 	_STRUCT_XMM_REG		__fpu_ymmh15;		/* YMMH 15  */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k0;		/* K0 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k1;		/* K1 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k2;		/* K2 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k3;		/* K3 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k4;		/* K4 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k5;		/* K5 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k6;		/* K6 */
    // DEBUG: 	_STRUCT_OPMASK_REG	__fpu_k7;		/* K7 */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh0;		/* ZMMH 0  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh1;		/* ZMMH 1  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh2;		/* ZMMH 2  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh3;		/* ZMMH 3  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh4;		/* ZMMH 4  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh5;		/* ZMMH 5  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh6;		/* ZMMH 6  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh7;		/* ZMMH 7  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh8;		/* ZMMH 8  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh9;		/* ZMMH 9  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh10;		/* ZMMH 10  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh11;		/* ZMMH 11  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh12;		/* ZMMH 12  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh13;		/* ZMMH 13  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh14;		/* ZMMH 14  */
    // DEBUG: 	_STRUCT_YMM_REG		__fpu_zmmh15;		/* ZMMH 15  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm16;		/* ZMM 16  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm17;		/* ZMM 17  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm18;		/* ZMM 18  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm19;		/* ZMM 19  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm20;		/* ZMM 20  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm21;		/* ZMM 21  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm22;		/* ZMM 22  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm23;		/* ZMM 23  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm24;		/* ZMM 24  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm25;		/* ZMM 25  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm26;		/* ZMM 26  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm27;		/* ZMM 27  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm28;		/* ZMM 28  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm29;		/* ZMM 29  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm30;		/* ZMM 30  */
    // DEBUG: 	_STRUCT_ZMM_REG		__fpu_zmm31;		/* ZMM 31  */
    // DEBUG: }
    public unsafe partial class DarwinX86Avx512State64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2444)]
        public partial struct __Internal
        {
            internal fixed int __fpu_reserved[2];
            internal global::Sentry.Native.DarwinFpControl.__Internal __fpu_fcw;
            internal global::Sentry.Native.DarwinFpStatus.__Internal __fpu_fsw;
            internal byte __fpu_ftw;
            internal byte __fpu_rsrv1;
            internal ushort __fpu_fop;
            internal uint __fpu_ip;
            internal ushort __fpu_cs;
            internal ushort __fpu_rsrv2;
            internal uint __fpu_dp;
            internal ushort __fpu_ds;
            internal ushort __fpu_rsrv3;
            internal uint __fpu_mxcsr;
            internal uint __fpu_mxcsrmask;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm0;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm1;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm2;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm3;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm4;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm5;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm6;
            internal global::Sentry.Native.DarwinMmstReg.__Internal __fpu_stmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm8;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm9;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm10;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm11;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm12;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm13;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm14;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_xmm15;
            internal fixed sbyte __fpu_rsrv4[96];
            internal int __fpu_reserved1;
            internal fixed sbyte __avx_reserved1[64];
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh0;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh1;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh2;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh3;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh4;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh5;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh6;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh7;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh8;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh9;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh10;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh11;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh12;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh13;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh14;
            internal global::Sentry.Native.DarwinXmmReg.__Internal __fpu_ymmh15;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k0;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k1;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k2;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k3;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k4;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k5;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k6;
            internal global::Sentry.Native.DarwinOpmaskReg.__Internal __fpu_k7;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh0;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh1;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh2;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh3;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh4;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh5;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh6;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh7;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh8;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh9;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh10;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh11;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh12;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh13;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh14;
            internal global::Sentry.Native.DarwinYmmReg.__Internal __fpu_zmmh15;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm16;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm17;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm18;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm19;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm20;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm21;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm22;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm23;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm24;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm25;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm26;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm27;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm28;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm29;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm30;
            internal global::Sentry.Native.DarwinZmmReg.__Internal __fpu_zmm31;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86Avx512State64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86Avx512State64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86Avx512State64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86Avx512State64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86Avx512State64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86Avx512State64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86Avx512State64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86Avx512State64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86Avx512State64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86Avx512State64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int[] FpuReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->__fpu_reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__fpu_reserved[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinFpControl FpuFcw
        {
            get
            {
                return global::Sentry.Native.DarwinFpControl.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fcw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fcw = *(global::Sentry.Native.DarwinFpControl.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinFpStatus FpuFsw
        {
            get
            {
                return global::Sentry.Native.DarwinFpStatus.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_fsw));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_fsw = *(global::Sentry.Native.DarwinFpStatus.__Internal*) value.__Instance;
            }
        }

        public byte FpuFtw
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ftw;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ftw = value;
            }
        }

        public byte FpuRsrv1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv1 = value;
            }
        }

        public ushort FpuFop
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_fop;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_fop = value;
            }
        }

        public uint FpuIp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ip;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ip = value;
            }
        }

        public ushort FpuCs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_cs;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_cs = value;
            }
        }

        public ushort FpuRsrv2
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv2;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv2 = value;
            }
        }

        public uint FpuDp
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_dp;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_dp = value;
            }
        }

        public ushort FpuDs
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_ds;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_ds = value;
            }
        }

        public ushort FpuRsrv3
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_rsrv3;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_rsrv3 = value;
            }
        }

        public uint FpuMxcsr
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsr;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsr = value;
            }
        }

        public uint FpuMxcsrmask
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_mxcsrmask;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_mxcsrmask = value;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm0
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm0 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm1
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm1 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm2
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm2 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm3
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm3 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm4
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm4 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm5
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm5 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm6
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm6 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinMmstReg FpuStmm7
        {
            get
            {
                return global::Sentry.Native.DarwinMmstReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_stmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_stmm7 = *(global::Sentry.Native.DarwinMmstReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm8
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm8 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm9
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm9 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm10
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm10 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm11
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm11 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm12
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm12 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm13
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm13 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm14
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm14 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuXmm15
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_xmm15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_xmm15 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public sbyte[] FpuRsrv4
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__fpu_rsrv4, 96);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 96; i++)
                        ((__Internal*)__Instance)->__fpu_rsrv4[i] = value[i];
                }
            }
        }

        public int FpuReserved1
        {
            get
            {
                return ((__Internal*)__Instance)->__fpu_reserved1;
            }

            set
            {
                ((__Internal*)__Instance)->__fpu_reserved1 = value;
            }
        }

        public sbyte[] AvxReserved1
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->__avx_reserved1, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->__avx_reserved1[i] = value[i];
                }
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh0
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh0 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh1
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh1 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh2
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh2 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh3
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh3 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh4
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh4 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh5
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh5 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh6
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh6 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh7
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh7 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh8
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh8 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh9
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh9 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh10
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh10 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh11
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh11 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh12
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh12 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh13
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh13 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh14
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh14 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinXmmReg FpuYmmh15
        {
            get
            {
                return global::Sentry.Native.DarwinXmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_ymmh15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_ymmh15 = *(global::Sentry.Native.DarwinXmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK0
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k0 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK1
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k1 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK2
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k2 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK3
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k3 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK4
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k4 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK5
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k5 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK6
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k6 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinOpmaskReg FpuK7
        {
            get
            {
                return global::Sentry.Native.DarwinOpmaskReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_k7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_k7 = *(global::Sentry.Native.DarwinOpmaskReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh0
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh0 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh1
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh1 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh2
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh2 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh3
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh3));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh3 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh4
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh4));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh4 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh5
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh5));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh5 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh6
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh6));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh6 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh7
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh7));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh7 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh8
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh8));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh8 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh9
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh9));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh9 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh10
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh10));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh10 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh11
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh11));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh11 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh12
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh12));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh12 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh13
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh13));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh13 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh14
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh14));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh14 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinYmmReg FpuZmmh15
        {
            get
            {
                return global::Sentry.Native.DarwinYmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmmh15));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmmh15 = *(global::Sentry.Native.DarwinYmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm16
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm16));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm16 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm17
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm17));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm17 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm18
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm18));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm18 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm19
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm19));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm19 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm20
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm20));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm20 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm21
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm21));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm21 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm22
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm22));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm22 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm23
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm23));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm23 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm24
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm24));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm24 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm25
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm25));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm25 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm26
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm26));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm26 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm27
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm27));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm27 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm28
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm28));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm28 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm29
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm29));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm29 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm30
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm30));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm30 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinZmmReg FpuZmm31
        {
            get
            {
                return global::Sentry.Native.DarwinZmmReg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fpu_zmm31));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fpu_zmm31 = *(global::Sentry.Native.DarwinZmmReg.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_X86_EXCEPTION_STATE64
    // DEBUG: {
    // DEBUG:     __uint16_t	__trapno;
    // DEBUG:     __uint16_t	__cpu;
    // DEBUG:     __uint32_t	__err;
    // DEBUG:     __uint64_t	__faultvaddr;
    // DEBUG: }
    public unsafe partial class DarwinX86ExceptionState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort __trapno;
            internal ushort __cpu;
            internal uint __err;
            internal ulong __faultvaddr;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86ExceptionState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86ExceptionState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86ExceptionState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86ExceptionState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86ExceptionState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86ExceptionState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86ExceptionState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86ExceptionState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86ExceptionState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86ExceptionState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Trapno
        {
            get
            {
                return ((__Internal*)__Instance)->__trapno;
            }

            set
            {
                ((__Internal*)__Instance)->__trapno = value;
            }
        }

        public ushort Cpu
        {
            get
            {
                return ((__Internal*)__Instance)->__cpu;
            }

            set
            {
                ((__Internal*)__Instance)->__cpu = value;
            }
        }

        public uint Err
        {
            get
            {
                return ((__Internal*)__Instance)->__err;
            }

            set
            {
                ((__Internal*)__Instance)->__err = value;
            }
        }

        public ulong Faultvaddr
        {
            get
            {
                return ((__Internal*)__Instance)->__faultvaddr;
            }

            set
            {
                ((__Internal*)__Instance)->__faultvaddr = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_DEBUG_STATE64
    // DEBUG: {
    // DEBUG: 	__uint64_t	__dr0;
    // DEBUG: 	__uint64_t	__dr1;
    // DEBUG: 	__uint64_t	__dr2;
    // DEBUG: 	__uint64_t	__dr3;
    // DEBUG: 	__uint64_t	__dr4;
    // DEBUG: 	__uint64_t	__dr5;
    // DEBUG: 	__uint64_t	__dr6;
    // DEBUG: 	__uint64_t	__dr7;
    // DEBUG: }
    public unsafe partial class DarwinX86DebugState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal ulong __dr0;
            internal ulong __dr1;
            internal ulong __dr2;
            internal ulong __dr3;
            internal ulong __dr4;
            internal ulong __dr5;
            internal ulong __dr6;
            internal ulong __dr7;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86DebugState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86DebugState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86DebugState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86DebugState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86DebugState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86DebugState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86DebugState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86DebugState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86DebugState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86DebugState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Dr0
        {
            get
            {
                return ((__Internal*)__Instance)->__dr0;
            }

            set
            {
                ((__Internal*)__Instance)->__dr0 = value;
            }
        }

        public ulong Dr1
        {
            get
            {
                return ((__Internal*)__Instance)->__dr1;
            }

            set
            {
                ((__Internal*)__Instance)->__dr1 = value;
            }
        }

        public ulong Dr2
        {
            get
            {
                return ((__Internal*)__Instance)->__dr2;
            }

            set
            {
                ((__Internal*)__Instance)->__dr2 = value;
            }
        }

        public ulong Dr3
        {
            get
            {
                return ((__Internal*)__Instance)->__dr3;
            }

            set
            {
                ((__Internal*)__Instance)->__dr3 = value;
            }
        }

        public ulong Dr4
        {
            get
            {
                return ((__Internal*)__Instance)->__dr4;
            }

            set
            {
                ((__Internal*)__Instance)->__dr4 = value;
            }
        }

        public ulong Dr5
        {
            get
            {
                return ((__Internal*)__Instance)->__dr5;
            }

            set
            {
                ((__Internal*)__Instance)->__dr5 = value;
            }
        }

        public ulong Dr6
        {
            get
            {
                return ((__Internal*)__Instance)->__dr6;
            }

            set
            {
                ((__Internal*)__Instance)->__dr6 = value;
            }
        }

        public ulong Dr7
        {
            get
            {
                return ((__Internal*)__Instance)->__dr7;
            }

            set
            {
                ((__Internal*)__Instance)->__dr7 = value;
            }
        }
    }

    // DEBUG: _STRUCT_X86_CPMU_STATE64
    // DEBUG: {
    // DEBUG: 	__uint64_t __ctrs[16];
    // DEBUG: }
    public unsafe partial class DarwinX86CpmuState64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 128)]
        public partial struct __Internal
        {
            internal fixed ulong __ctrs[16];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86CpmuState64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinX86CpmuState64>();

        protected bool __ownsNativeInstance;

        internal static DarwinX86CpmuState64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinX86CpmuState64(native.ToPointer(), skipVTables);
        }

        internal static DarwinX86CpmuState64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinX86CpmuState64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinX86CpmuState64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinX86CpmuState64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinX86CpmuState64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinX86CpmuState64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong[] Ctrs
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ulong>(((__Internal*)__Instance)->__ctrs, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->__ctrs[i] = value[i];
                }
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT32
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE32   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_STATE32      __ss;
    // DEBUG: 	_STRUCT_X86_FLOAT_STATE32       __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontext32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 600)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinI386ExceptionState.__Internal __es;
            internal global::Sentry.Native.DarwinI386ThreadState.__Internal __ss;
            internal global::Sentry.Native.DarwinI386FloatState.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontext32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontext32>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontext32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontext32(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontext32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontext32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontext32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontext32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontext32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontext32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinI386ExceptionState Es
        {
            get
            {
                return global::Sentry.Native.DarwinI386ExceptionState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinI386ExceptionState.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinI386ThreadState Ss
        {
            get
            {
                return global::Sentry.Native.DarwinI386ThreadState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinI386ThreadState.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinI386FloatState Fs
        {
            get
            {
                return global::Sentry.Native.DarwinI386FloatState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinI386FloatState.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT_AVX32
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE32   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_STATE32      __ss;
    // DEBUG: 	_STRUCT_X86_AVX_STATE32         __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontextAvx32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 792)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinI386ExceptionState.__Internal __es;
            internal global::Sentry.Native.DarwinI386ThreadState.__Internal __ss;
            internal global::Sentry.Native.DarwinI386AvxState.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx32>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx32(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinI386ExceptionState Es
        {
            get
            {
                return global::Sentry.Native.DarwinI386ExceptionState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinI386ExceptionState.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinI386ThreadState Ss
        {
            get
            {
                return global::Sentry.Native.DarwinI386ThreadState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinI386ThreadState.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinI386AvxState Fs
        {
            get
            {
                return global::Sentry.Native.DarwinI386AvxState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinI386AvxState.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT_AVX512_32
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE32   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_STATE32      __ss;
    // DEBUG: 	_STRUCT_X86_AVX512_STATE32      __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontextAvx512_32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1112)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinI386ExceptionState.__Internal __es;
            internal global::Sentry.Native.DarwinI386ThreadState.__Internal __ss;
            internal global::Sentry.Native.DarwinI386Avx512State.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx512_32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx512_32>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx512_32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_32(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx512_32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx512_32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx512_32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx512_32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx512_32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinI386ExceptionState Es
        {
            get
            {
                return global::Sentry.Native.DarwinI386ExceptionState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinI386ExceptionState.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinI386ThreadState Ss
        {
            get
            {
                return global::Sentry.Native.DarwinI386ThreadState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinI386ThreadState.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinI386Avx512State Fs
        {
            get
            {
                return global::Sentry.Native.DarwinI386Avx512State.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinI386Avx512State.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT64
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE64   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_STATE64      __ss;
    // DEBUG: 	_STRUCT_X86_FLOAT_STATE64       __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontext64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 712)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinX86ExceptionState64.__Internal __es;
            internal global::Sentry.Native.DarwinX86ThreadState64.__Internal __ss;
            internal global::Sentry.Native.DarwinX86FloatState64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontext64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontext64>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontext64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontext64(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontext64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontext64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontext64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontext64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontext64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontext64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::Sentry.Native.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86ThreadState64 Ss
        {
            get
            {
                return global::Sentry.Native.DarwinX86ThreadState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinX86ThreadState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86FloatState64 Fs
        {
            get
            {
                return global::Sentry.Native.DarwinX86FloatState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinX86FloatState64.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT64_FULL
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE64   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_FULL_STATE64 __ss;
    // DEBUG: 	_STRUCT_X86_FLOAT_STATE64       __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontext64Full : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 744)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinX86ExceptionState64.__Internal __es;
            internal global::Sentry.Native.DarwinX86ThreadFullState64.__Internal __ss;
            internal global::Sentry.Native.DarwinX86FloatState64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontext64Full> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontext64Full>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontext64Full __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontext64Full(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontext64Full __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontext64Full)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontext64Full __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontext64Full(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontext64Full(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontext64Full(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::Sentry.Native.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86ThreadFullState64 Ss
        {
            get
            {
                return global::Sentry.Native.DarwinX86ThreadFullState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinX86ThreadFullState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86FloatState64 Fs
        {
            get
            {
                return global::Sentry.Native.DarwinX86FloatState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinX86FloatState64.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT_AVX64
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE64   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_STATE64      __ss;
    // DEBUG: 	_STRUCT_X86_AVX_STATE64         __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontextAvx64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1032)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinX86ExceptionState64.__Internal __es;
            internal global::Sentry.Native.DarwinX86ThreadState64.__Internal __ss;
            internal global::Sentry.Native.DarwinX86AvxState64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx64>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx64(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::Sentry.Native.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86ThreadState64 Ss
        {
            get
            {
                return global::Sentry.Native.DarwinX86ThreadState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinX86ThreadState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86AvxState64 Fs
        {
            get
            {
                return global::Sentry.Native.DarwinX86AvxState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinX86AvxState64.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT_AVX64_FULL
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE64   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_FULL_STATE64 __ss;
    // DEBUG: 	_STRUCT_X86_AVX_STATE64         __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontextAvx64Full : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1064)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinX86ExceptionState64.__Internal __es;
            internal global::Sentry.Native.DarwinX86ThreadFullState64.__Internal __ss;
            internal global::Sentry.Native.DarwinX86AvxState64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx64Full> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx64Full>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx64Full __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx64Full(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx64Full __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx64Full)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx64Full __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx64Full(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx64Full(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx64Full(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::Sentry.Native.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86ThreadFullState64 Ss
        {
            get
            {
                return global::Sentry.Native.DarwinX86ThreadFullState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinX86ThreadFullState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86AvxState64 Fs
        {
            get
            {
                return global::Sentry.Native.DarwinX86AvxState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinX86AvxState64.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT_AVX512_64
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE64   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_STATE64      __ss;
    // DEBUG: 	_STRUCT_X86_AVX512_STATE64      __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontextAvx512_64 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2632)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinX86ExceptionState64.__Internal __es;
            internal global::Sentry.Native.DarwinX86ThreadState64.__Internal __ss;
            internal global::Sentry.Native.DarwinX86Avx512State64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx512_64> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx512_64>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx512_64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_64(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx512_64 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx512_64)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx512_64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_64(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx512_64(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx512_64(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::Sentry.Native.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86ThreadState64 Ss
        {
            get
            {
                return global::Sentry.Native.DarwinX86ThreadState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinX86ThreadState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86Avx512State64 Fs
        {
            get
            {
                return global::Sentry.Native.DarwinX86Avx512State64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinX86Avx512State64.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_MCONTEXT_AVX512_64_FULL
    // DEBUG: {
    // DEBUG: 	_STRUCT_X86_EXCEPTION_STATE64   __es;
    // DEBUG: 	_STRUCT_X86_THREAD_FULL_STATE64 __ss;
    // DEBUG: 	_STRUCT_X86_AVX512_STATE64      __fs;
    // DEBUG: }
    public unsafe partial class DarwinMcontextAvx512_64Full : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2664)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.DarwinX86ExceptionState64.__Internal __es;
            internal global::Sentry.Native.DarwinX86ThreadFullState64.__Internal __ss;
            internal global::Sentry.Native.DarwinX86Avx512State64.__Internal __fs;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx512_64Full> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinMcontextAvx512_64Full>();

        protected bool __ownsNativeInstance;

        internal static DarwinMcontextAvx512_64Full __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_64Full(native.ToPointer(), skipVTables);
        }

        internal static DarwinMcontextAvx512_64Full __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinMcontextAvx512_64Full)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinMcontextAvx512_64Full __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinMcontextAvx512_64Full(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinMcontextAvx512_64Full(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinMcontextAvx512_64Full(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.DarwinX86ExceptionState64 Es
        {
            get
            {
                return global::Sentry.Native.DarwinX86ExceptionState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__es));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__es = *(global::Sentry.Native.DarwinX86ExceptionState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86ThreadFullState64 Ss
        {
            get
            {
                return global::Sentry.Native.DarwinX86ThreadFullState64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__ss));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__ss = *(global::Sentry.Native.DarwinX86ThreadFullState64.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinX86Avx512State64 Fs
        {
            get
            {
                return global::Sentry.Native.DarwinX86Avx512State64.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->__fs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->__fs = *(global::Sentry.Native.DarwinX86Avx512State64.__Internal*) value.__Instance;
            }
        }
    }

    // DEBUG: _STRUCT_SIGALTSTACK
    // DEBUG: {
    // DEBUG: 	void            *ss_sp;         /* signal stack base */
    // DEBUG: 	__darwin_size_t ss_size;        /* signal stack length */
    // DEBUG: 	int             ss_flags;       /* SA_DISABLE and/or SA_ONSTACK */
    // DEBUG: }
    public unsafe partial class DarwinSigaltstack : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr ss_sp;
            internal ulong ss_size;
            internal int ss_flags;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinSigaltstack> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinSigaltstack>();

        protected bool __ownsNativeInstance;

        internal static DarwinSigaltstack __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinSigaltstack(native.ToPointer(), skipVTables);
        }

        internal static DarwinSigaltstack __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinSigaltstack)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinSigaltstack __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinSigaltstack(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinSigaltstack(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinSigaltstack(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr SsSp
        {
            get
            {
                return ((__Internal*)__Instance)->ss_sp;
            }

            set
            {
                ((__Internal*)__Instance)->ss_sp = (__IntPtr) value;
            }
        }

        public ulong SsSize
        {
            get
            {
                return ((__Internal*)__Instance)->ss_size;
            }

            set
            {
                ((__Internal*)__Instance)->ss_size = value;
            }
        }

        public int SsFlags
        {
            get
            {
                return ((__Internal*)__Instance)->ss_flags;
            }

            set
            {
                ((__Internal*)__Instance)->ss_flags = value;
            }
        }
    }

    // DEBUG: _STRUCT_UCONTEXT
    // DEBUG: {
    // DEBUG: 	int                     uc_onstack;
    // DEBUG: 	__darwin_sigset_t       uc_sigmask;     /* signal mask used by this context */
    // DEBUG: 	_STRUCT_SIGALTSTACK     uc_stack;       /* stack used by this context */
    // DEBUG: 	_STRUCT_UCONTEXT        *uc_link;       /* pointer to resuming context */
    // DEBUG: 	__darwin_size_t         uc_mcsize;      /* size of the machine context passed in */
    // DEBUG: 	_STRUCT_MCONTEXT        *uc_mcontext;   /* pointer to machine specific context */
    // DEBUG: #ifdef _XOPEN_SOURCE
    // DEBUG: 	_STRUCT_MCONTEXT        __mcontext_data;
    // DEBUG: #endif /* _XOPEN_SOURCE */
    // DEBUG: }
    public unsafe partial class DarwinUcontext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal int uc_onstack;
            internal uint uc_sigmask;
            internal global::Sentry.Native.DarwinSigaltstack.__Internal uc_stack;
            internal __IntPtr uc_link;
            internal ulong uc_mcsize;
            internal __IntPtr uc_mcontext;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinUcontext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.DarwinUcontext>();

        protected bool __ownsNativeInstance;

        internal static DarwinUcontext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DarwinUcontext(native.ToPointer(), skipVTables);
        }

        internal static DarwinUcontext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DarwinUcontext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DarwinUcontext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DarwinUcontext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DarwinUcontext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DarwinUcontext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int UcOnstack
        {
            get
            {
                return ((__Internal*)__Instance)->uc_onstack;
            }

            set
            {
                ((__Internal*)__Instance)->uc_onstack = value;
            }
        }

        public uint UcSigmask
        {
            get
            {
                return ((__Internal*)__Instance)->uc_sigmask;
            }

            set
            {
                ((__Internal*)__Instance)->uc_sigmask = value;
            }
        }

        public global::Sentry.Native.DarwinSigaltstack UcStack
        {
            get
            {
                return global::Sentry.Native.DarwinSigaltstack.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uc_stack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uc_stack = *(global::Sentry.Native.DarwinSigaltstack.__Internal*) value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinUcontext UcLink
        {
            get
            {
                var __result0 = global::Sentry.Native.DarwinUcontext.__GetOrCreateInstance(((__Internal*)__Instance)->uc_link, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->uc_link = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ulong UcMcsize
        {
            get
            {
                return ((__Internal*)__Instance)->uc_mcsize;
            }

            set
            {
                ((__Internal*)__Instance)->uc_mcsize = value;
            }
        }

        public global::Sentry.Native.DarwinMcontext64 UcMcontext
        {
            get
            {
                var __result0 = global::Sentry.Native.DarwinMcontext64.__GetOrCreateInstance(((__Internal*)__Instance)->uc_mcontext, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->uc_mcontext = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    // DEBUG: union sigval {
    // DEBUG: 	/* Members as suggested by Annex C of POSIX 1003.1b. */
    // DEBUG: 	int     sival_int;
    // DEBUG: 	void    *sival_ptr;
    // DEBUG: }
    public unsafe partial struct Sigval
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int sival_int;

            [FieldOffset(0)]
            internal __IntPtr sival_ptr;
        }

        private Sigval.__Internal __instance;
        internal Sigval.__Internal __Instance { get { return __instance; } }

        internal static Sigval __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigval(native.ToPointer(), skipVTables);
        }

        internal static Sigval __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigval(native, skipVTables);
        }

        private Sigval(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Sigval(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Sentry.Native.Sigval.__Internal*) native;
        }

        public int SivalInt
        {
            get
            {
                return __instance.sival_int;
            }

            set
            {
                __instance.sival_int = value;
            }
        }

        public __IntPtr SivalPtr
        {
            get
            {
                return __instance.sival_ptr;
            }

            set
            {
                __instance.sival_ptr = (__IntPtr) value;
            }
        }
    }

    // DEBUG: struct sigevent {
    // DEBUG: 	int                             sigev_notify;                           /* Notification type */
    // DEBUG: 	int                             sigev_signo;                            /* Signal number */
    // DEBUG: 	union sigval    sigev_value;                            /* Signal value */
    // DEBUG: 	void                    (*sigev_notify_function)(union sigval);   /* Notification function */
    // DEBUG: 	pthread_attr_t  *sigev_notify_attributes;       /* Notification attributes */
    // DEBUG: }
    public unsafe partial class Sigevent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal int sigev_notify;
            internal int sigev_signo;
            internal global::Sentry.Native.Sigval.__Internal sigev_value;
            internal __IntPtr sigev_notify_function;
            internal __IntPtr sigev_notify_attributes;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Sigevent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Sigevent>();

        protected bool __ownsNativeInstance;

        internal static Sigevent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigevent(native.ToPointer(), skipVTables);
        }

        internal static Sigevent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Sigevent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Sigevent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigevent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sigevent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sigevent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int SigevNotify
        {
            get
            {
                return ((__Internal*)__Instance)->sigev_notify;
            }

            set
            {
                ((__Internal*)__Instance)->sigev_notify = value;
            }
        }

        public int SigevSigno
        {
            get
            {
                return ((__Internal*)__Instance)->sigev_signo;
            }

            set
            {
                ((__Internal*)__Instance)->sigev_signo = value;
            }
        }

        public global::Sentry.Native.Sigval SigevValue
        {
            get
            {
                return global::Sentry.Native.Sigval.__CreateInstance(((__Internal*)__Instance)->sigev_value);
            }

            set
            {
                ((__Internal*)__Instance)->sigev_value = value.__Instance;
            }
        }

        public global::Sentry.Native.Delegates.Action_Sentry_Native_sigval___Internal SigevNotifyFunction
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->sigev_notify_function;
                return __ptr0 == IntPtr.Zero? null : (global::Sentry.Native.Delegates.Action_Sentry_Native_sigval___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sentry.Native.Delegates.Action_Sentry_Native_sigval___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->sigev_notify_function = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sentry.Native.OpaquePthreadAttrT SigevNotifyAttributes
        {
            get
            {
                var __result0 = global::Sentry.Native.OpaquePthreadAttrT.__GetOrCreateInstance(((__Internal*)__Instance)->sigev_notify_attributes, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->sigev_notify_attributes = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    // DEBUG: struct __siginfo {
    // DEBUG: 	int     si_signo;               /* signal number */
    // DEBUG: 	int     si_errno;               /* errno association */
    // DEBUG: 	int     si_code;                /* signal code */
    // DEBUG: 	pid_t   si_pid;                 /* sending process */
    // DEBUG: 	uid_t   si_uid;                 /* sender's ruid */
    // DEBUG: 	int     si_status;              /* exit value */
    // DEBUG: 	void    *si_addr;               /* faulting instruction */
    // DEBUG: 	union sigval si_value;          /* signal value */
    // DEBUG: 	long    si_band;                /* band event for SIGPOLL */
    // DEBUG: 	unsigned long   __pad[7];       /* Reserved for Future Use */
    // DEBUG: }
    public unsafe partial class Siginfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            internal int si_signo;
            internal int si_errno;
            internal int si_code;
            internal int si_pid;
            internal uint si_uid;
            internal int si_status;
            internal __IntPtr si_addr;
            internal global::Sentry.Native.Sigval.__Internal si_value;
            internal long si_band;
            internal fixed ulong __pad[7];
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Siginfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Siginfo>();

        protected bool __ownsNativeInstance;

        internal static Siginfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Siginfo(native.ToPointer(), skipVTables);
        }

        internal static Siginfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Siginfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Siginfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Siginfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Siginfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Siginfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int SiSigno
        {
            get
            {
                return ((__Internal*)__Instance)->si_signo;
            }

            set
            {
                ((__Internal*)__Instance)->si_signo = value;
            }
        }

        public int SiErrno
        {
            get
            {
                return ((__Internal*)__Instance)->si_errno;
            }

            set
            {
                ((__Internal*)__Instance)->si_errno = value;
            }
        }

        public int SiCode
        {
            get
            {
                return ((__Internal*)__Instance)->si_code;
            }

            set
            {
                ((__Internal*)__Instance)->si_code = value;
            }
        }

        public int SiPid
        {
            get
            {
                return ((__Internal*)__Instance)->si_pid;
            }

            set
            {
                ((__Internal*)__Instance)->si_pid = value;
            }
        }

        public uint SiUid
        {
            get
            {
                return ((__Internal*)__Instance)->si_uid;
            }

            set
            {
                ((__Internal*)__Instance)->si_uid = value;
            }
        }

        public int SiStatus
        {
            get
            {
                return ((__Internal*)__Instance)->si_status;
            }

            set
            {
                ((__Internal*)__Instance)->si_status = value;
            }
        }

        public __IntPtr SiAddr
        {
            get
            {
                return ((__Internal*)__Instance)->si_addr;
            }

            set
            {
                ((__Internal*)__Instance)->si_addr = (__IntPtr) value;
            }
        }

        public global::Sentry.Native.Sigval SiValue
        {
            get
            {
                return global::Sentry.Native.Sigval.__CreateInstance(((__Internal*)__Instance)->si_value);
            }

            set
            {
                ((__Internal*)__Instance)->si_value = value.__Instance;
            }
        }

        public long SiBand
        {
            get
            {
                return ((__Internal*)__Instance)->si_band;
            }

            set
            {
                ((__Internal*)__Instance)->si_band = value;
            }
        }

        public ulong[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ulong>(((__Internal*)__Instance)->__pad, 7);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 7; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    // DEBUG: union __sigaction_u {
    // DEBUG: 	void    (*__sa_handler)(int);
    // DEBUG: 	void    (*__sa_sigaction)(int, struct __siginfo *,
    // DEBUG: 	    void *);
    // DEBUG: }
    public unsafe partial struct SigactionU
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr __sa_handler;

            [FieldOffset(0)]
            internal __IntPtr __sa_sigaction;
        }

        private SigactionU.__Internal __instance;
        internal SigactionU.__Internal __Instance { get { return __instance; } }

        internal static SigactionU __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SigactionU(native.ToPointer(), skipVTables);
        }

        internal static SigactionU __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SigactionU(native, skipVTables);
        }

        private SigactionU(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private SigactionU(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Sentry.Native.SigactionU.__Internal*) native;
        }

        public global::Sentry.Native.Delegates.Action_int SaHandler
        {
            get
            {
                var __ptr0 = __instance.__sa_handler;
                return __ptr0 == IntPtr.Zero? null : (global::Sentry.Native.Delegates.Action_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sentry.Native.Delegates.Action_int));
            }

            set
            {
                __instance.__sa_handler = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Sentry.Native.Delegates.Action_int___IntPtr___IntPtr SaSigaction
        {
            get
            {
                var __ptr0 = __instance.__sa_sigaction;
                return __ptr0 == IntPtr.Zero? null : (global::Sentry.Native.Delegates.Action_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sentry.Native.Delegates.Action_int___IntPtr___IntPtr));
            }

            set
            {
                __instance.__sa_sigaction = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    // DEBUG: struct  __sigaction {
    // DEBUG: 	union __sigaction_u __sigaction_u;  /* signal handler */
    // DEBUG: 	void    (*sa_tramp)(void *, int, int, siginfo_t *, void *);
    // DEBUG: 	sigset_t sa_mask;               /* signal mask to apply */
    // DEBUG: 	int     sa_flags;               /* see signal options below */
    // DEBUG: }
    public unsafe partial class Sigaction : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.SigactionU.__Internal __sigaction_u;
            internal __IntPtr sa_tramp;
            internal uint sa_mask;
            internal int sa_flags;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Sigaction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Sigaction>();

        protected bool __ownsNativeInstance;

        internal static Sigaction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigaction(native.ToPointer(), skipVTables);
        }

        internal static Sigaction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Sigaction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Sigaction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigaction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sigaction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sigaction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.SigactionU SigactionU
        {
            get
            {
                return global::Sentry.Native.SigactionU.__CreateInstance(((__Internal*)__Instance)->__sigaction_u);
            }

            set
            {
                ((__Internal*)__Instance)->__sigaction_u = value.__Instance;
            }
        }

        public global::Sentry.Native.Delegates.Action___IntPtr_int_int___IntPtr___IntPtr SaTramp
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->sa_tramp;
                return __ptr0 == IntPtr.Zero? null : (global::Sentry.Native.Delegates.Action___IntPtr_int_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sentry.Native.Delegates.Action___IntPtr_int_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->sa_tramp = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public uint SaMask
        {
            get
            {
                return ((__Internal*)__Instance)->sa_mask;
            }

            set
            {
                ((__Internal*)__Instance)->sa_mask = value;
            }
        }

        public int SaFlags
        {
            get
            {
                return ((__Internal*)__Instance)->sa_flags;
            }

            set
            {
                ((__Internal*)__Instance)->sa_flags = value;
            }
        }
    }

    // DEBUG: struct  sigaction {
    // DEBUG: 	union __sigaction_u __sigaction_u;  /* signal handler */
    // DEBUG: 	sigset_t sa_mask;               /* signal mask to apply */
    // DEBUG: 	int     sa_flags;               /* see signal options below */
    // DEBUG: }
    public unsafe partial class sigaction : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::Sentry.Native.SigactionU.__Internal __sigaction_u;
            internal uint sa_mask;
            internal int sa_flags;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.sigaction> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.sigaction>();

        protected bool __ownsNativeInstance;

        internal static sigaction __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new sigaction(native.ToPointer(), skipVTables);
        }

        internal static sigaction __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (sigaction)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static sigaction __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new sigaction(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private sigaction(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected sigaction(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.SigactionU SigactionU
        {
            get
            {
                return global::Sentry.Native.SigactionU.__CreateInstance(((__Internal*)__Instance)->__sigaction_u);
            }

            set
            {
                ((__Internal*)__Instance)->__sigaction_u = value.__Instance;
            }
        }

        public uint SaMask
        {
            get
            {
                return ((__Internal*)__Instance)->sa_mask;
            }

            set
            {
                ((__Internal*)__Instance)->sa_mask = value;
            }
        }

        public int SaFlags
        {
            get
            {
                return ((__Internal*)__Instance)->sa_flags;
            }

            set
            {
                ((__Internal*)__Instance)->sa_flags = value;
            }
        }
    }

    // DEBUG: struct  sigvec {
    // DEBUG: 	void    (*sv_handler)(int);     /* signal handler */
    // DEBUG: 	int     sv_mask;                /* signal mask to apply */
    // DEBUG: 	int     sv_flags;               /* see signal options below */
    // DEBUG: }
    public unsafe partial class Sigvec : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr sv_handler;
            internal int sv_mask;
            internal int sv_flags;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Sigvec> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Sigvec>();

        protected bool __ownsNativeInstance;

        internal static Sigvec __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigvec(native.ToPointer(), skipVTables);
        }

        internal static Sigvec __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Sigvec)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Sigvec __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigvec(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sigvec(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sigvec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Sentry.Native.Delegates.Action_int SvHandler
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->sv_handler;
                return __ptr0 == IntPtr.Zero? null : (global::Sentry.Native.Delegates.Action_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Sentry.Native.Delegates.Action_int));
            }

            set
            {
                ((__Internal*)__Instance)->sv_handler = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public int SvMask
        {
            get
            {
                return ((__Internal*)__Instance)->sv_mask;
            }

            set
            {
                ((__Internal*)__Instance)->sv_mask = value;
            }
        }

        public int SvFlags
        {
            get
            {
                return ((__Internal*)__Instance)->sv_flags;
            }

            set
            {
                ((__Internal*)__Instance)->sv_flags = value;
            }
        }
    }

    // DEBUG: struct  sigstack {
    // DEBUG: 	char    *ss_sp;                 /* signal stack pointer */
    // DEBUG: 	int     ss_onstack;             /* current status */
    // DEBUG: }
    public unsafe partial class Sigstack : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr ss_sp;
            internal int ss_onstack;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Sigstack> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.Sigstack>();

        protected bool __ownsNativeInstance;

        internal static Sigstack __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Sigstack(native.ToPointer(), skipVTables);
        }

        internal static Sigstack __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Sigstack)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Sigstack __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Sigstack(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sigstack(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sigstack(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* SsSp
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->ss_sp;
            }

            set
            {
                ((__Internal*)__Instance)->ss_sp = (__IntPtr) value;
            }
        }

        public int SsOnstack
        {
            get
            {
                return ((__Internal*)__Instance)->ss_onstack;
            }

            set
            {
                ((__Internal*)__Instance)->ss_onstack = value;
            }
        }
    }

    /// <summary>Represents a sentry protocol value.</summary>
    /// <remarks>
    /// <para>The members of this type should never be accessed.  They are only here</para>
    /// <para>so that alignment for the type can be properly determined.</para>
    /// <para>Values must be released with `sentry_value_decref`.  This lowers the</para>
    /// <para>internal refcount by one.  If the refcount hits zero it's freed.  Some</para>
    /// <para>values like primitives have no refcount (like null) so operations on</para>
    /// <para>those are no-ops.</para>
    /// <para>In addition values can be frozen.  Some values like primitives are always</para>
    /// <para>frozen but lists and dicts are not and can be frozen on demand.  This</para>
    /// <para>automatically happens for some shared values in the event payload like</para>
    /// <para>the module list.</para>
    /// </remarks>
    // DEBUG: union sentry_value_u {
    // DEBUG:     uint64_t _bits;
    // DEBUG:     double _double;
    // DEBUG: }
    public unsafe partial struct SentryValueU
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong _bits;

            [FieldOffset(0)]
            internal double _double;

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "_ZN14sentry_value_uC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        private SentryValueU.__Internal __instance;
        internal SentryValueU.__Internal __Instance { get { return __instance; } }

        internal static SentryValueU __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryValueU(native.ToPointer(), skipVTables);
        }

        internal static SentryValueU __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryValueU(native, skipVTables);
        }

        private SentryValueU(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private SentryValueU(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::Sentry.Native.SentryValueU.__Internal*) native;
        }

        // DEBUG: sentry_value_u
        public SentryValueU(global::Sentry.Native.SentryValueU _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public ulong Bits
        {
            get
            {
                return __instance._bits;
            }

            set
            {
                __instance._bits = value;
            }
        }

        public double Double
        {
            get
            {
                return __instance._double;
            }

            set
            {
                __instance._double = value;
            }
        }
    }

    /// <summary>
    /// <para>This represents the OS dependent user context in the case of a crash, and can</para>
    /// <para>be used to manually capture a crash.</para>
    /// </summary>
    // DEBUG: struct sentry_ucontext_s {
    // DEBUG: #ifdef _WIN32
    // DEBUG:     EXCEPTION_POINTERS exception_ptrs;
    // DEBUG: #else
    // DEBUG:     int signum;
    // DEBUG:     siginfo_t *siginfo;
    // DEBUG:     ucontext_t *user_context;
    // DEBUG: #endif
    // DEBUG: }
    public unsafe partial class SentryUcontextS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int signum;
            internal __IntPtr siginfo;
            internal __IntPtr user_context;

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "_ZN17sentry_ucontext_sC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryUcontextS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryUcontextS>();

        protected bool __ownsNativeInstance;

        internal static SentryUcontextS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryUcontextS(native.ToPointer(), skipVTables);
        }

        internal static SentryUcontextS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryUcontextS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryUcontextS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryUcontextS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryUcontextS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryUcontextS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        // DEBUG: sentry_ucontext_s
        public SentryUcontextS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sentry.Native.SentryUcontextS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        // DEBUG: sentry_ucontext_s
        public SentryUcontextS(global::Sentry.Native.SentryUcontextS _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sentry.Native.SentryUcontextS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sentry.Native.SentryUcontextS.__Internal*) __Instance) = *((global::Sentry.Native.SentryUcontextS.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Signum
        {
            get
            {
                return ((__Internal*)__Instance)->signum;
            }

            set
            {
                ((__Internal*)__Instance)->signum = value;
            }
        }

        public global::Sentry.Native.Siginfo Siginfo
        {
            get
            {
                var __result0 = global::Sentry.Native.Siginfo.__GetOrCreateInstance(((__Internal*)__Instance)->siginfo, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->siginfo = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::Sentry.Native.DarwinUcontext UserContext
        {
            get
            {
                var __result0 = global::Sentry.Native.DarwinUcontext.__GetOrCreateInstance(((__Internal*)__Instance)->user_context, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->user_context = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>A UUID</summary>
    // DEBUG: struct sentry_uuid_s {
    // DEBUG:     char bytes[16];
    // DEBUG: }
    public unsafe partial class SentryUuidS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed sbyte bytes[16];

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "_ZN13sentry_uuid_sC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryUuidS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Sentry.Native.SentryUuidS>();

        protected bool __ownsNativeInstance;

        internal static SentryUuidS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SentryUuidS(native.ToPointer(), skipVTables);
        }

        internal static SentryUuidS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SentryUuidS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SentryUuidS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SentryUuidS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SentryUuidS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SentryUuidS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        // DEBUG: sentry_uuid_s
        public SentryUuidS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sentry.Native.SentryUuidS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        // DEBUG: sentry_uuid_s
        public SentryUuidS(global::Sentry.Native.SentryUuidS _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Sentry.Native.SentryUuidS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Sentry.Native.SentryUuidS.__Internal*) __Instance) = *((global::Sentry.Native.SentryUuidS.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Bytes
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->bytes, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->bytes[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class sentry
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "__sigbits", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Sigbits(int __signo);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_malloc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryMalloc(ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryFree(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_incref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryValueIncref(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_decref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryValueDecref(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_refcount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SentryValueRefcount(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_freeze", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryValueFreeze(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_is_frozen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueIsFrozen(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_null", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewNull();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_int32", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewInt32(int value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_double", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewDouble(double value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_bool", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewBool(int value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewString([MarshalAs(UnmanagedType.LPUTF8Str)] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewList();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_object", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewObject();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueTypeT SentryValueGetType(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_set_by_key", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueSetByKey(global::Sentry.Native.SentryValueU.__Internal value, [MarshalAs(UnmanagedType.LPUTF8Str)] string k, global::Sentry.Native.SentryValueU.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_remove_by_key", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueRemoveByKey(global::Sentry.Native.SentryValueU.__Internal value, [MarshalAs(UnmanagedType.LPUTF8Str)] string k);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_append", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueAppend(global::Sentry.Native.SentryValueU.__Internal value, global::Sentry.Native.SentryValueU.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_set_by_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueSetByIndex(global::Sentry.Native.SentryValueU.__Internal value, ulong index, global::Sentry.Native.SentryValueU.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_remove_by_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueRemoveByIndex(global::Sentry.Native.SentryValueU.__Internal value, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_get_by_key", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueGetByKey(global::Sentry.Native.SentryValueU.__Internal value, [MarshalAs(UnmanagedType.LPUTF8Str)] string k);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_get_by_key_owned", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueGetByKeyOwned(global::Sentry.Native.SentryValueU.__Internal value, [MarshalAs(UnmanagedType.LPUTF8Str)] string k);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_get_by_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueGetByIndex(global::Sentry.Native.SentryValueU.__Internal value, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_get_by_index_owned", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueGetByIndexOwned(global::Sentry.Native.SentryValueU.__Internal value, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_get_length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SentryValueGetLength(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_as_int32", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueAsInt32(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_as_double", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double SentryValueAsDouble(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_as_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryValueAsString(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_is_true", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueIsTrue(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_is_null", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryValueIsNull(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_to_json", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* SentryValueToJson(global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewEvent();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_message_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewMessageEvent(global::Sentry.Native.SentryLevelE level, [MarshalAs(UnmanagedType.LPUTF8Str)] string logger, [MarshalAs(UnmanagedType.LPUTF8Str)] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_new_breadcrumb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryValueNewBreadcrumb([MarshalAs(UnmanagedType.LPUTF8Str)] string type, [MarshalAs(UnmanagedType.LPUTF8Str)] string message);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_value_to_msgpack", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* SentryValueToMsgpack(global::Sentry.Native.SentryValueU.__Internal value, ulong* size_out);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_event_value_add_stacktrace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryEventValueAddStacktrace(global::Sentry.Native.SentryValueU.__Internal @event, void** ips, ulong len);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_unwind_stack", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SentryUnwindStack(__IntPtr addr, void** stacktrace_out, ulong max_len);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_unwind_stack_from_ucontext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong SentryUnwindStackFromUcontext(__IntPtr uctx, void** stacktrace_out, ulong max_len);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_uuid_nil", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryUuidS.__Internal SentryUuidNil();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_uuid_new_v4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryUuidS.__Internal SentryUuidNewV4();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_uuid_from_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryUuidS.__Internal SentryUuidFromString([MarshalAs(UnmanagedType.LPUTF8Str)] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_uuid_from_bytes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryUuidS.__Internal SentryUuidFromBytes(sbyte[] bytes);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_uuid_is_nil", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryUuidIsNil(__IntPtr uuid);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_uuid_as_bytes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUuidAsBytes(__IntPtr uuid, sbyte[] bytes);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_uuid_as_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUuidAsString(__IntPtr uuid, sbyte[] str);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_envelope_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryEnvelopeFree(__IntPtr envelope);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_envelope_get_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryEnvelopeGetEvent(__IntPtr envelope);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_envelope_serialize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* SentryEnvelopeSerialize(__IntPtr envelope, ulong* size_out);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_envelope_write_to_file", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryEnvelopeWriteToFile(__IntPtr envelope, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_transport_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryTransportNew(__IntPtr send_func);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_transport_set_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportSetState(__IntPtr transport, __IntPtr state);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_transport_set_free_func", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportSetFreeFunc(__IntPtr transport, __IntPtr free_func);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_transport_set_startup_func", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportSetStartupFunc(__IntPtr transport, __IntPtr startup_func);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_transport_set_shutdown_func", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportSetShutdownFunc(__IntPtr transport, __IntPtr shutdown_func);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_transport_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryTransportFree(__IntPtr transport);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_new_function_transport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryNewFunctionTransport(__IntPtr func, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsNew();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsFree(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_transport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetTransport(__IntPtr opts, __IntPtr transport);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_before_send", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetBeforeSend(__IntPtr opts, __IntPtr func, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_dsn", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetDsn(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string dsn);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_dsn", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetDsn(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_sample_rate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetSampleRate(__IntPtr opts, double sample_rate);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_sample_rate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double SentryOptionsGetSampleRate(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetRelease(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string release);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetRelease(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_environment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetEnvironment(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string environment);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_environment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetEnvironment(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_dist", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetDist(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string dist);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_dist", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetDist(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_http_proxy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetHttpProxy(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string proxy);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_http_proxy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetHttpProxy(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_ca_certs", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetCaCerts(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_ca_certs", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetCaCerts(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_transport_thread_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetTransportThreadName(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_transport_thread_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SentryOptionsGetTransportThreadName(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_debug", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetDebug(__IntPtr opts, int debug);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_debug", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryOptionsGetDebug(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_auto_session_tracking", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetAutoSessionTracking(__IntPtr opts, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_auto_session_tracking", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryOptionsGetAutoSessionTracking(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_require_user_consent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetRequireUserConsent(__IntPtr opts, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_require_user_consent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryOptionsGetRequireUserConsent(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_symbolize_stacktraces", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetSymbolizeStacktraces(__IntPtr opts, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_get_symbolize_stacktraces", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryOptionsGetSymbolizeStacktraces(__IntPtr opts);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_add_attachment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsAddAttachment(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_handler_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetHandlerPath(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_database_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetDatabasePath(__IntPtr opts, [MarshalAs(UnmanagedType.LPUTF8Str)] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_options_set_system_crash_reporter_enabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryOptionsSetSystemCrashReporterEnabled(__IntPtr opts, int enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryInit(__IntPtr options);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_shutdown", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SentryShutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_get_modules_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryValueU.__Internal SentryGetModulesList();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_clear_modulecache", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryClearModulecache();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_user_consent_give", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUserConsentGive();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_user_consent_revoke", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUserConsentRevoke();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_user_consent_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryUserConsentReset();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_user_consent_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryUserConsentT SentryUserConsentGet();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_capture_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Sentry.Native.SentryUuidS.__Internal SentryCaptureEvent(global::Sentry.Native.SentryValueU.__Internal @event);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_handle_exception", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryHandleException(__IntPtr uctx);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_add_breadcrumb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryAddBreadcrumb(global::Sentry.Native.SentryValueU.__Internal breadcrumb);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_set_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetUser(global::Sentry.Native.SentryValueU.__Internal user);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_remove_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveUser();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_set_tag", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetTag([MarshalAs(UnmanagedType.LPUTF8Str)] string key, [MarshalAs(UnmanagedType.LPUTF8Str)] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_remove_tag", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveTag([MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_set_extra", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetExtra([MarshalAs(UnmanagedType.LPUTF8Str)] string key, global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_remove_extra", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveExtra([MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_set_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetContext([MarshalAs(UnmanagedType.LPUTF8Str)] string key, global::Sentry.Native.SentryValueU.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_remove_context", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveContext([MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_set_fingerprint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetFingerprint([MarshalAs(UnmanagedType.LPUTF8Str)] string fingerprint);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_remove_fingerprint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveFingerprint();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_set_transaction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetTransaction([MarshalAs(UnmanagedType.LPUTF8Str)] string transaction);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_remove_transaction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryRemoveTransaction();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_set_level", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentrySetLevel(global::Sentry.Native.SentryLevelE level);

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_start_session", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryStartSession();

            [SuppressUnmanagedCodeSecurity, DllImport("SentryNative", EntryPoint = "sentry_end_session", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SentryEndSession();
        }

        // DEBUG: __header_always_inline int
        // DEBUG: __sigbits(int __signo)
        // DEBUG: {
        // DEBUG:     return __signo > __DARWIN_NSIG ? 0 : (1 << (__signo - 1));
        // DEBUG: }
        public static int Sigbits(int __signo)
        {
            var __ret = __Internal.Sigbits(__signo);
            return __ret;
        }

        /// <summary>Allocates memory with the underlying allocator.</summary>
        // DEBUG: SENTRY_API void *sentry_malloc(size_t size)
        public static __IntPtr SentryMalloc(ulong size)
        {
            var __ret = __Internal.SentryMalloc(size);
            return __ret;
        }

        /// <summary>Releases memory allocated from the underlying allocator.</summary>
        // DEBUG: SENTRY_API void sentry_free(void *ptr)
        public static void SentryFree(__IntPtr ptr)
        {
            __Internal.SentryFree(ptr);
        }

        /// <summary>Increments the reference count on the value.</summary>
        // DEBUG: SENTRY_API void sentry_value_incref(sentry_value_t value)
        public static void SentryValueIncref(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            __Internal.SentryValueIncref(__arg0);
        }

        /// <summary>Decrements the reference count on the value.</summary>
        // DEBUG: SENTRY_API void sentry_value_decref(sentry_value_t value)
        public static void SentryValueDecref(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            __Internal.SentryValueDecref(__arg0);
        }

        /// <summary>Returns the refcount of a value.</summary>
        // DEBUG: SENTRY_API size_t sentry_value_refcount(sentry_value_t value)
        public static ulong SentryValueRefcount(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueRefcount(__arg0);
            return __ret;
        }

        /// <summary>Freezes a value.</summary>
        // DEBUG: SENTRY_API void sentry_value_freeze(sentry_value_t value)
        public static void SentryValueFreeze(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            __Internal.SentryValueFreeze(__arg0);
        }

        /// <summary>Checks if a value is frozen.</summary>
        // DEBUG: SENTRY_API int sentry_value_is_frozen(sentry_value_t value)
        public static int SentryValueIsFrozen(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueIsFrozen(__arg0);
            return __ret;
        }

        /// <summary>Creates a null value.</summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_null(void)
        public static global::Sentry.Native.SentryValueU SentryValueNewNull()
        {
            var __ret = __Internal.SentryValueNewNull();
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new 32-bit signed integer value.</summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_int32(int32_t value)
        public static global::Sentry.Native.SentryValueU SentryValueNewInt32(int value)
        {
            var __ret = __Internal.SentryValueNewInt32(value);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new double value.</summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_double(double value)
        public static global::Sentry.Native.SentryValueU SentryValueNewDouble(double value)
        {
            var __ret = __Internal.SentryValueNewDouble(value);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new boolen value.</summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_bool(int value)
        public static global::Sentry.Native.SentryValueU SentryValueNewBool(int value)
        {
            var __ret = __Internal.SentryValueNewBool(value);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new null terminated string.</summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_string(const char *value)
        public static global::Sentry.Native.SentryValueU SentryValueNewString(string value)
        {
            var __ret = __Internal.SentryValueNewString(value);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new list value.</summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_list(void)
        public static global::Sentry.Native.SentryValueU SentryValueNewList()
        {
            var __ret = __Internal.SentryValueNewList();
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new object.</summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_object(void)
        public static global::Sentry.Native.SentryValueU SentryValueNewObject()
        {
            var __ret = __Internal.SentryValueNewObject();
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Returns the type of the value passed.</summary>
        // DEBUG: SENTRY_API sentry_value_type_t sentry_value_get_type(sentry_value_t value)
        public static global::Sentry.Native.SentryValueTypeT SentryValueGetType(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetType(__arg0);
            return __ret;
        }

        /// <summary>Sets a key to a value in the map.</summary>
        /// <remarks>
        /// <para>This moves the ownership of the value into the map.  The caller does not</para>
        /// <para>have to call `sentry_value_decref` on it.</para>
        /// </remarks>
        // DEBUG: SENTRY_API int sentry_value_set_by_key(
        // DEBUG:     sentry_value_t value, const char *k, sentry_value_t v)
        public static int SentryValueSetByKey(global::Sentry.Native.SentryValueU value, string k, global::Sentry.Native.SentryValueU v)
        {
            var __arg0 = value.__Instance;
            var __arg2 = v.__Instance;
            var __ret = __Internal.SentryValueSetByKey(__arg0, k, __arg2);
            return __ret;
        }

        /// <summary>This removes a value from the map by key.</summary>
        // DEBUG: SENTRY_API int sentry_value_remove_by_key(sentry_value_t value, const char *k)
        public static int SentryValueRemoveByKey(global::Sentry.Native.SentryValueU value, string k)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueRemoveByKey(__arg0, k);
            return __ret;
        }

        /// <summary>Appends a value to a list.</summary>
        /// <remarks>
        /// <para>This moves the ownership of the value into the list.  The caller does not</para>
        /// <para>have to call `sentry_value_decref` on it.</para>
        /// </remarks>
        // DEBUG: SENTRY_API int sentry_value_append(sentry_value_t value, sentry_value_t v)
        public static int SentryValueAppend(global::Sentry.Native.SentryValueU value, global::Sentry.Native.SentryValueU v)
        {
            var __arg0 = value.__Instance;
            var __arg1 = v.__Instance;
            var __ret = __Internal.SentryValueAppend(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Inserts a value into the list at a certain position.</summary>
        /// <remarks>
        /// <para>This moves the ownership of the value into the list.  The caller does not</para>
        /// <para>have to call `sentry_value_decref` on it.</para>
        /// <para>If the list is shorter than the given index it's automatically extended</para>
        /// <para>and filled with `null` values.</para>
        /// </remarks>
        // DEBUG: SENTRY_API int sentry_value_set_by_index(
        // DEBUG:     sentry_value_t value, size_t index, sentry_value_t v)
        public static int SentryValueSetByIndex(global::Sentry.Native.SentryValueU value, ulong index, global::Sentry.Native.SentryValueU v)
        {
            var __arg0 = value.__Instance;
            var __arg2 = v.__Instance;
            var __ret = __Internal.SentryValueSetByIndex(__arg0, index, __arg2);
            return __ret;
        }

        /// <summary>This removes a value from the list by index.</summary>
        // DEBUG: SENTRY_API int sentry_value_remove_by_index(sentry_value_t value, size_t index)
        public static int SentryValueRemoveByIndex(global::Sentry.Native.SentryValueU value, ulong index)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueRemoveByIndex(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Looks up a value in a map by key.  If missing a null value is returned.</para>
        /// <para>The returned value is borrowed.</para>
        /// </summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_get_by_key(
        // DEBUG:     sentry_value_t value, const char *k)
        public static global::Sentry.Native.SentryValueU SentryValueGetByKey(global::Sentry.Native.SentryValueU value, string k)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetByKey(__arg0, k);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Looks up a value in a map by key.  If missing a null value is returned.</para>
        /// <para>The returned value is owned.</para>
        /// </summary>
        /// <remarks>
        /// <para>If the caller no longer needs the value it must be released with</para>
        /// <para>`sentry_value_decref`.</para>
        /// </remarks>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_get_by_key_owned(
        // DEBUG:     sentry_value_t value, const char *k)
        public static global::Sentry.Native.SentryValueU SentryValueGetByKeyOwned(global::Sentry.Native.SentryValueU value, string k)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetByKeyOwned(__arg0, k);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Looks up a value in a list by index.  If missing a null value is returned.</para>
        /// <para>The returned value is borrowed.</para>
        /// </summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_get_by_index(
        // DEBUG:     sentry_value_t value, size_t index)
        public static global::Sentry.Native.SentryValueU SentryValueGetByIndex(global::Sentry.Native.SentryValueU value, ulong index)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetByIndex(__arg0, index);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Looks up a value in a list by index.  If missing a null value is</para>
        /// <para>returned. The returned value is owned.</para>
        /// </summary>
        /// <remarks>
        /// <para>If the caller no longer needs the value it must be released with</para>
        /// <para>`sentry_value_decref`.</para>
        /// </remarks>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_get_by_index_owned(
        // DEBUG:     sentry_value_t value, size_t index)
        public static global::Sentry.Native.SentryValueU SentryValueGetByIndexOwned(global::Sentry.Native.SentryValueU value, ulong index)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetByIndexOwned(__arg0, index);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Returns the length of the given map or list.</summary>
        /// <remarks>If an item is not a list or map the return value is 0.</remarks>
        // DEBUG: SENTRY_API size_t sentry_value_get_length(sentry_value_t value)
        public static ulong SentryValueGetLength(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueGetLength(__arg0);
            return __ret;
        }

        /// <summary>Converts a value into a 32bit signed integer.</summary>
        // DEBUG: SENTRY_API int32_t sentry_value_as_int32(sentry_value_t value)
        public static int SentryValueAsInt32(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueAsInt32(__arg0);
            return __ret;
        }

        /// <summary>Converts a value into a double value.</summary>
        // DEBUG: SENTRY_API double sentry_value_as_double(sentry_value_t value)
        public static double SentryValueAsDouble(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueAsDouble(__arg0);
            return __ret;
        }

        /// <summary>Returns the value as c string.</summary>
        // DEBUG: SENTRY_API const char *sentry_value_as_string(sentry_value_t value)
        public static string SentryValueAsString(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueAsString(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Returns `true` if the value is boolean true.</summary>
        // DEBUG: SENTRY_API int sentry_value_is_true(sentry_value_t value)
        public static int SentryValueIsTrue(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueIsTrue(__arg0);
            return __ret;
        }

        /// <summary>Returns `true` if the value is null.</summary>
        // DEBUG: SENTRY_API int sentry_value_is_null(sentry_value_t value)
        public static int SentryValueIsNull(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueIsNull(__arg0);
            return __ret;
        }

        /// <summary>Serialize a sentry value to JSON.</summary>
        /// <remarks>
        /// <para>The string is freshly allocated and must be freed with</para>
        /// <para>`sentry_string_free`.</para>
        /// </remarks>
        // DEBUG: SENTRY_API char *sentry_value_to_json(sentry_value_t value)
        public static sbyte* SentryValueToJson(global::Sentry.Native.SentryValueU value)
        {
            var __arg0 = value.__Instance;
            var __ret = __Internal.SentryValueToJson(__arg0);
            return __ret;
        }

        /// <summary>Creates a new empty event value.</summary>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_event(void)
        public static global::Sentry.Native.SentryValueU SentryValueNewEvent()
        {
            var __ret = __Internal.SentryValueNewEvent();
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new message event value.</summary>
        /// <remarks>`logger` can be NULL to omit the logger value.</remarks>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_message_event(
        // DEBUG:     sentry_level_t level, const char *logger, const char *text)
        public static global::Sentry.Native.SentryValueU SentryValueNewMessageEvent(global::Sentry.Native.SentryLevelE level, string logger, string text)
        {
            var __ret = __Internal.SentryValueNewMessageEvent(level, logger, text);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Creates a new breadcrumb with a specific type and message.</summary>
        /// <remarks>Either parameter can be NULL in which case no such attributes is created.</remarks>
        // DEBUG: SENTRY_API sentry_value_t sentry_value_new_breadcrumb(
        // DEBUG:     const char *type, const char *message)
        public static global::Sentry.Native.SentryValueU SentryValueNewBreadcrumb(string type, string message)
        {
            var __ret = __Internal.SentryValueNewBreadcrumb(type, message);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Serialize a sentry value to msgpack.</summary>
        /// <remarks>
        /// <para>The string is freshly allocated and must be freed with</para>
        /// <para>`sentry_string_free`.  Since msgpack is not zero terminated</para>
        /// <para>the size is written to the `size_out` parameter.</para>
        /// </remarks>
        // DEBUG: SENTRY_EXPERIMENTAL_API char *sentry_value_to_msgpack(
        // DEBUG:     sentry_value_t value, size_t *size_out)
        public static sbyte* SentryValueToMsgpack(global::Sentry.Native.SentryValueU value, ref ulong size_out)
        {
            var __arg0 = value.__Instance;
            fixed (ulong* __size_out1 = &size_out)
            {
                var __arg1 = __size_out1;
                var __ret = __Internal.SentryValueToMsgpack(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Adds a stacktrace to an event.</summary>
        /// <remarks>
        /// <para>If `ips` is NULL the current stacktrace is captured, otherwise `len`</para>
        /// <para>stacktrace instruction pointers are attached to the event.</para>
        /// </remarks>
        // DEBUG: SENTRY_EXPERIMENTAL_API void sentry_event_value_add_stacktrace(
        // DEBUG:     sentry_value_t event, void **ips, size_t len)
        public static void SentryEventValueAddStacktrace(global::Sentry.Native.SentryValueU @event, void** ips, ulong len)
        {
            var __arg0 = @event.__Instance;
            __Internal.SentryEventValueAddStacktrace(__arg0, ips, len);
        }

        /// <summary>Unwinds the stack from the given address.</summary>
        /// <remarks>
        /// <para>If the address is given in `addr` the stack is unwound form there.</para>
        /// <para>Otherwise (NULL is passed) the current instruction pointer is used as</para>
        /// <para>start address. The stacktrace is written to `stacktrace_out` with upt o</para>
        /// <para>`max_len` frames being written.  The actual number of unwound stackframes</para>
        /// <para>is returned.</para>
        /// </remarks>
        // DEBUG: SENTRY_EXPERIMENTAL_API size_t sentry_unwind_stack(
        // DEBUG:     void *addr, void **stacktrace_out, size_t max_len)
        public static ulong SentryUnwindStack(__IntPtr addr, void** stacktrace_out, ulong max_len)
        {
            var __ret = __Internal.SentryUnwindStack(addr, stacktrace_out, max_len);
            return __ret;
        }

        /// <summary>Unwinds the stack from the given context.</summary>
        /// <remarks>
        /// <para>The stacktrace is written to `stacktrace_out` with upt o `max_len` frames</para>
        /// <para>being written.  The actual number of unwound stackframes is returned.</para>
        /// </remarks>
        // DEBUG: SENTRY_EXPERIMENTAL_API size_t sentry_unwind_stack_from_ucontext(
        // DEBUG:     const sentry_ucontext_t *uctx, void **stacktrace_out, size_t max_len)
        public static ulong SentryUnwindStackFromUcontext(global::Sentry.Native.SentryUcontextS uctx, void** stacktrace_out, ulong max_len)
        {
            var __arg0 = uctx is null ? __IntPtr.Zero : uctx.__Instance;
            var __ret = __Internal.SentryUnwindStackFromUcontext(__arg0, stacktrace_out, max_len);
            return __ret;
        }

        /// <summary>Creates the nil uuid.</summary>
        // DEBUG: SENTRY_API sentry_uuid_t sentry_uuid_nil(void)
        public static global::Sentry.Native.SentryUuidS SentryUuidNil()
        {
            var __ret = __Internal.SentryUuidNil();
            return global::Sentry.Native.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Creates a new uuid4.</summary>
        // DEBUG: SENTRY_API sentry_uuid_t sentry_uuid_new_v4(void)
        public static global::Sentry.Native.SentryUuidS SentryUuidNewV4()
        {
            var __ret = __Internal.SentryUuidNewV4();
            return global::Sentry.Native.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Parses a uuid from a string.</summary>
        // DEBUG: SENTRY_API sentry_uuid_t sentry_uuid_from_string(const char *str)
        public static global::Sentry.Native.SentryUuidS SentryUuidFromString(string str)
        {
            var __ret = __Internal.SentryUuidFromString(str);
            return global::Sentry.Native.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Creates a uuid from bytes.</summary>
        // DEBUG: SENTRY_API sentry_uuid_t sentry_uuid_from_bytes(const char bytes[16])
        public static global::Sentry.Native.SentryUuidS SentryUuidFromBytes(sbyte[] bytes)
        {
            if (bytes == null || bytes.Length != 16)
                throw new ArgumentOutOfRangeException("bytes", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SentryUuidFromBytes(bytes);
            return global::Sentry.Native.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Checks if the uuid is nil.</summary>
        // DEBUG: SENTRY_API int sentry_uuid_is_nil(const sentry_uuid_t *uuid)
        public static int SentryUuidIsNil(global::Sentry.Native.SentryUuidS uuid)
        {
            var __arg0 = uuid is null ? __IntPtr.Zero : uuid.__Instance;
            var __ret = __Internal.SentryUuidIsNil(__arg0);
            return __ret;
        }

        /// <summary>Returns the bytes of the uuid.</summary>
        // DEBUG: SENTRY_API void sentry_uuid_as_bytes(const sentry_uuid_t *uuid, char bytes[16])
        public static void SentryUuidAsBytes(global::Sentry.Native.SentryUuidS uuid, sbyte[] bytes)
        {
            var __arg0 = uuid is null ? __IntPtr.Zero : uuid.__Instance;
            if (bytes == null || bytes.Length != 16)
                throw new ArgumentOutOfRangeException("bytes", "The dimensions of the provided array don't match the required size.");
            __Internal.SentryUuidAsBytes(__arg0, bytes);
        }

        /// <summary>Formats the uuid into a string buffer.</summary>
        // DEBUG: SENTRY_API void sentry_uuid_as_string(const sentry_uuid_t *uuid, char str[37])
        public static void SentryUuidAsString(global::Sentry.Native.SentryUuidS uuid, sbyte[] str)
        {
            var __arg0 = uuid is null ? __IntPtr.Zero : uuid.__Instance;
            if (str == null || str.Length != 37)
                throw new ArgumentOutOfRangeException("str", "The dimensions of the provided array don't match the required size.");
            __Internal.SentryUuidAsString(__arg0, str);
        }

        /// <summary>Frees an envelope.</summary>
        // DEBUG: SENTRY_API void sentry_envelope_free(sentry_envelope_t *envelope)
        public static void SentryEnvelopeFree(global::Sentry.Native.SentryEnvelopeS envelope)
        {
            var __arg0 = envelope is null ? __IntPtr.Zero : envelope.__Instance;
            __Internal.SentryEnvelopeFree(__arg0);
        }

        /// <summary>Given an envelope returns the embedded event if there is one.</summary>
        /// <remarks>This returns a borrowed value to the event in the envelope.</remarks>
        // DEBUG: SENTRY_API sentry_value_t sentry_envelope_get_event(
        // DEBUG:     const sentry_envelope_t *envelope)
        public static global::Sentry.Native.SentryValueU SentryEnvelopeGetEvent(global::Sentry.Native.SentryEnvelopeS envelope)
        {
            var __arg0 = envelope is null ? __IntPtr.Zero : envelope.__Instance;
            var __ret = __Internal.SentryEnvelopeGetEvent(__arg0);
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Serializes the envelope.</summary>
        /// <remarks>The return value needs to be freed with sentry_string_free().</remarks>
        // DEBUG: SENTRY_API char *sentry_envelope_serialize(
        // DEBUG:     const sentry_envelope_t *envelope, size_t *size_out)
        public static sbyte* SentryEnvelopeSerialize(global::Sentry.Native.SentryEnvelopeS envelope, ref ulong size_out)
        {
            var __arg0 = envelope is null ? __IntPtr.Zero : envelope.__Instance;
            fixed (ulong* __size_out1 = &size_out)
            {
                var __arg1 = __size_out1;
                var __ret = __Internal.SentryEnvelopeSerialize(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Serializes the envelope into a file.</summary>
        /// <remarks>
        /// <para>`path` is assumed to be in platform-specific filesystem path encoding.</para>
        /// <para>Returns 0 on success.</para>
        /// </remarks>
        // DEBUG: SENTRY_API int sentry_envelope_write_to_file(
        // DEBUG:     const sentry_envelope_t *envelope, const char *path)
        public static int SentryEnvelopeWriteToFile(global::Sentry.Native.SentryEnvelopeS envelope, string path)
        {
            var __arg0 = envelope is null ? __IntPtr.Zero : envelope.__Instance;
            var __ret = __Internal.SentryEnvelopeWriteToFile(__arg0, path);
            return __ret;
        }

        /// <summary>Creates a new transport with an initial `send_func`.</summary>
        // DEBUG: SENTRY_API sentry_transport_t *sentry_transport_new(
        // DEBUG:     void (*send_func)(sentry_envelope_t *envelope, void *state))
        public static global::Sentry.Native.SentryTransportS SentryTransportNew(global::Sentry.Native.Delegates.Action___IntPtr___IntPtr send_func)
        {
            var __arg0 = send_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(send_func);
            var __ret = __Internal.SentryTransportNew(__arg0);
            var __result0 = global::Sentry.Native.SentryTransportS.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Sets the transport `state`.</summary>
        /// <remarks>
        /// <para>If the state is owned by the transport and needs to be freed, use</para>
        /// <para>`sentry_transport_set_free_func` to set an appropriate hook.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_transport_set_state(
        // DEBUG:     sentry_transport_t *transport, void *state)
        public static void SentryTransportSetState(global::Sentry.Native.SentryTransportS transport, __IntPtr state)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            __Internal.SentryTransportSetState(__arg0, state);
        }

        /// <summary>Sets the transport hook to free the transport `state`.</summary>
        // DEBUG: SENTRY_API void sentry_transport_set_free_func(
        // DEBUG:     sentry_transport_t *transport, void (*free_func)(void *state))
        public static void SentryTransportSetFreeFunc(global::Sentry.Native.SentryTransportS transport, global::Sentry.Native.Delegates.Action___IntPtr free_func)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            var __arg1 = free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_func);
            __Internal.SentryTransportSetFreeFunc(__arg0, __arg1);
        }

        /// <summary>Sets the transport startup hook.</summary>
        /// <remarks>
        /// <para>This hook is called from within `sentry_init` and will get a reference to the</para>
        /// <para>options which can be used to initialize a transports internal state.</para>
        /// <para>It should return `0` on success. A failure will bubble up to `sentry_init`.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_transport_set_startup_func(sentry_transport_t *transport,
        // DEBUG:     int (*startup_func)(const sentry_options_t *options, void *state))
        public static void SentryTransportSetStartupFunc(global::Sentry.Native.SentryTransportS transport, global::Sentry.Native.Delegates.Func_int___IntPtr___IntPtr startup_func)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            var __arg1 = startup_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(startup_func);
            __Internal.SentryTransportSetStartupFunc(__arg0, __arg1);
        }

        /// <summary>Sets the transport shutdown hook.</summary>
        /// <remarks>
        /// <para>This hook will receive a millisecond-resolution timeout.</para>
        /// <para>It should return `0` on success in case all the pending envelopes have been</para>
        /// <para>sent within the timeout, or `1` if the timeout was hit.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_transport_set_shutdown_func(
        // DEBUG:     sentry_transport_t *transport,
        // DEBUG:     int (*shutdown_func)(uint64_t timeout, void *state))
        public static void SentryTransportSetShutdownFunc(global::Sentry.Native.SentryTransportS transport, global::Sentry.Native.Delegates.Func_int_ulong___IntPtr shutdown_func)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            var __arg1 = shutdown_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(shutdown_func);
            __Internal.SentryTransportSetShutdownFunc(__arg0, __arg1);
        }

        /// <summary>Generic way to free a transport.</summary>
        // DEBUG: SENTRY_API void sentry_transport_free(sentry_transport_t *transport)
        public static void SentryTransportFree(global::Sentry.Native.SentryTransportS transport)
        {
            var __arg0 = transport is null ? __IntPtr.Zero : transport.__Instance;
            __Internal.SentryTransportFree(__arg0);
        }

        /// <summary>Create a new function transport.</summary>
        /// <remarks>
        /// <para>It is a convenience function which works with a borrowed `data`, and will</para>
        /// <para>automatically free the envelope, so the user provided function does not need</para>
        /// <para>to do that.</para>
        /// <para>This function is *deprecated* and will be removed in a future version.</para>
        /// <para>It is here for backwards compatibility. Users should migrate to the</para>
        /// <para>`sentry_transport_new` API.</para>
        /// </remarks>
        // DEBUG: SENTRY_API sentry_transport_t *sentry_new_function_transport(
        // DEBUG:     void (*func)(const sentry_envelope_t *envelope, void *data), void *data)
        public static global::Sentry.Native.SentryTransportS SentryNewFunctionTransport(global::Sentry.Native.Delegates.Action___IntPtr___IntPtr func, __IntPtr data)
        {
            var __arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            var __ret = __Internal.SentryNewFunctionTransport(__arg0, data);
            var __result0 = global::Sentry.Native.SentryTransportS.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Creates a new options struct.</para>
        /// <para>Can be freed with `sentry_options_free`.</para>
        /// </summary>
        // DEBUG: SENTRY_API sentry_options_t *sentry_options_new(void)
        public static global::Sentry.Native.SentryOptionsS SentryOptionsNew()
        {
            var __ret = __Internal.SentryOptionsNew();
            var __result0 = global::Sentry.Native.SentryOptionsS.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Deallocates previously allocated sentry options.</summary>
        // DEBUG: SENTRY_API void sentry_options_free(sentry_options_t *opts)
        public static void SentryOptionsFree(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsFree(__arg0);
        }

        /// <summary>Sets a transport.</summary>
        // DEBUG: SENTRY_API void sentry_options_set_transport(
        // DEBUG:     sentry_options_t *opts, sentry_transport_t *transport)
        public static void SentryOptionsSetTransport(global::Sentry.Native.SentryOptionsS opts, global::Sentry.Native.SentryTransportS transport)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __arg1 = transport is null ? __IntPtr.Zero : transport.__Instance;
            __Internal.SentryOptionsSetTransport(__arg0, __arg1);
        }

        /// <summary>Sets the `before_send` callback.</summary>
        /// <remarks>See the `sentry_event_function_t` typedef above for more information.</remarks>
        // DEBUG: SENTRY_API void sentry_options_set_before_send(
        // DEBUG:     sentry_options_t *opts, sentry_event_function_t func, void *data)
        public static void SentryOptionsSetBeforeSend(global::Sentry.Native.SentryOptionsS opts, global::Sentry.Native.SentryEventFunctionT func, __IntPtr data)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __arg1 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            __Internal.SentryOptionsSetBeforeSend(__arg0, __arg1, data);
        }

        /// <summary>Sets the DSN.</summary>
        // DEBUG: SENTRY_API void sentry_options_set_dsn(sentry_options_t *opts, const char *dsn)
        public static void SentryOptionsSetDsn(global::Sentry.Native.SentryOptionsS opts, string dsn)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetDsn(__arg0, dsn);
        }

        /// <summary>Gets the DSN.</summary>
        // DEBUG: SENTRY_API const char *sentry_options_get_dsn(const sentry_options_t *opts)
        public static string SentryOptionsGetDsn(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetDsn(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>
        /// <para>Sets the sample rate, which should be a double between `0.0` and `1.0`.</para>
        /// <para>Sentry will randomly discard any event that is captured using</para>
        /// <para>`sentry_capture_event` when a sample rate&lt;&gt;1 is set.</para>
        /// </summary>
        // DEBUG: SENTRY_API void sentry_options_set_sample_rate(
        // DEBUG:     sentry_options_t *opts, double sample_rate)
        public static void SentryOptionsSetSampleRate(global::Sentry.Native.SentryOptionsS opts, double sample_rate)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetSampleRate(__arg0, sample_rate);
        }

        /// <summary>Gets the sample rate.</summary>
        // DEBUG: SENTRY_API double sentry_options_get_sample_rate(const sentry_options_t *opts)
        public static double SentryOptionsGetSampleRate(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetSampleRate(__arg0);
            return __ret;
        }

        /// <summary>Sets the release.</summary>
        // DEBUG: SENTRY_API void sentry_options_set_release(
        // DEBUG:     sentry_options_t *opts, const char *release)
        public static void SentryOptionsSetRelease(global::Sentry.Native.SentryOptionsS opts, string release)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetRelease(__arg0, release);
        }

        /// <summary>Gets the release.</summary>
        // DEBUG: SENTRY_API const char *sentry_options_get_release(const sentry_options_t *opts)
        public static string SentryOptionsGetRelease(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetRelease(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Sets the environment.</summary>
        // DEBUG: SENTRY_API void sentry_options_set_environment(
        // DEBUG:     sentry_options_t *opts, const char *environment)
        public static void SentryOptionsSetEnvironment(global::Sentry.Native.SentryOptionsS opts, string environment)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetEnvironment(__arg0, environment);
        }

        /// <summary>Gets the environment.</summary>
        // DEBUG: SENTRY_API const char *sentry_options_get_environment(
        // DEBUG:     const sentry_options_t *opts)
        public static string SentryOptionsGetEnvironment(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetEnvironment(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Sets the dist.</summary>
        // DEBUG: SENTRY_API void sentry_options_set_dist(
        // DEBUG:     sentry_options_t *opts, const char *dist)
        public static void SentryOptionsSetDist(global::Sentry.Native.SentryOptionsS opts, string dist)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetDist(__arg0, dist);
        }

        /// <summary>Gets the dist.</summary>
        // DEBUG: SENTRY_API const char *sentry_options_get_dist(const sentry_options_t *opts)
        public static string SentryOptionsGetDist(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetDist(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Configures the http proxy.</summary>
        /// <remarks>The given proxy has to include the full scheme, eg. `http://some.proxy/`.</remarks>
        // DEBUG: SENTRY_API void sentry_options_set_http_proxy(
        // DEBUG:     sentry_options_t *opts, const char *proxy)
        public static void SentryOptionsSetHttpProxy(global::Sentry.Native.SentryOptionsS opts, string proxy)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetHttpProxy(__arg0, proxy);
        }

        /// <summary>Returns the configured http proxy.</summary>
        // DEBUG: SENTRY_API const char *sentry_options_get_http_proxy(
        // DEBUG:     const sentry_options_t *opts)
        public static string SentryOptionsGetHttpProxy(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetHttpProxy(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>
        /// <para>Configures the path to a file containing ssl certificates for</para>
        /// <para>verification.</para>
        /// </summary>
        // DEBUG: SENTRY_API void sentry_options_set_ca_certs(
        // DEBUG:     sentry_options_t *opts, const char *path)
        public static void SentryOptionsSetCaCerts(global::Sentry.Native.SentryOptionsS opts, string path)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetCaCerts(__arg0, path);
        }

        /// <summary>Returns the configured path for ca certificates.</summary>
        // DEBUG: SENTRY_API const char *sentry_options_get_ca_certs(
        // DEBUG:     const sentry_options_t *opts)
        public static string SentryOptionsGetCaCerts(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetCaCerts(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Configures the name of the http transport thread.</summary>
        // DEBUG: SENTRY_API void sentry_options_set_transport_thread_name(
        // DEBUG:     sentry_options_t *opts, const char *name)
        public static void SentryOptionsSetTransportThreadName(global::Sentry.Native.SentryOptionsS opts, string name)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetTransportThreadName(__arg0, name);
        }

        /// <summary>Returns the configured http transport thread name.</summary>
        // DEBUG: SENTRY_API const char *sentry_options_get_transport_thread_name(
        // DEBUG:     const sentry_options_t *opts)
        public static string SentryOptionsGetTransportThreadName(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetTransportThreadName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Enables or disables debug printing mode.</summary>
        // DEBUG: SENTRY_API void sentry_options_set_debug(sentry_options_t *opts, int debug)
        public static void SentryOptionsSetDebug(global::Sentry.Native.SentryOptionsS opts, int debug)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetDebug(__arg0, debug);
        }

        /// <summary>Returns the current value of the debug flag.</summary>
        // DEBUG: SENTRY_API int sentry_options_get_debug(const sentry_options_t *opts)
        public static int SentryOptionsGetDebug(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetDebug(__arg0);
            return __ret;
        }

        /// <summary>Enables or disables automatic session tracking.</summary>
        /// <remarks>
        /// <para>Automatic session tracking is enabled by default and is equivalent to calling</para>
        /// <para>`sentry_start_session` after startup.</para>
        /// <para>There can only be one running session, and the current session will always be</para>
        /// <para>closed implicitly by `sentry_shutdown`, when starting a new session with</para>
        /// <para>`sentry_start_session`, or manually by calling `sentry_end_session`.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_options_set_auto_session_tracking(
        // DEBUG:     sentry_options_t *opts, int val)
        public static void SentryOptionsSetAutoSessionTracking(global::Sentry.Native.SentryOptionsS opts, int val)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetAutoSessionTracking(__arg0, val);
        }

        /// <summary>Returns true if automatic session tracking is enabled.</summary>
        // DEBUG: SENTRY_API int sentry_options_get_auto_session_tracking(
        // DEBUG:     const sentry_options_t *opts)
        public static int SentryOptionsGetAutoSessionTracking(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetAutoSessionTracking(__arg0);
            return __ret;
        }

        /// <summary>Enables or disables user consent requirements for uploads.</summary>
        /// <remarks>
        /// <para>This disables uploads until the user has given the consent to the SDK.</para>
        /// <para>Consent itself is given with `sentry_user_consent_give` and</para>
        /// <para>`sentry_user_consent_revoke`.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_options_set_require_user_consent(
        // DEBUG:     sentry_options_t *opts, int val)
        public static void SentryOptionsSetRequireUserConsent(global::Sentry.Native.SentryOptionsS opts, int val)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetRequireUserConsent(__arg0, val);
        }

        /// <summary>Returns true if user consent is required.</summary>
        // DEBUG: SENTRY_API int sentry_options_get_require_user_consent(
        // DEBUG:     const sentry_options_t *opts)
        public static int SentryOptionsGetRequireUserConsent(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetRequireUserConsent(__arg0);
            return __ret;
        }

        /// <summary>Enables or disables on-device symbolication of stack traces.</summary>
        /// <remarks>
        /// <para>This feature can have a performance impact, and is enabled by default on</para>
        /// <para>Android. It is usually only needed when it is not possible to provide debug</para>
        /// <para>information files for system libraries which are needed for serverside</para>
        /// <para>symbolication.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_options_set_symbolize_stacktraces(
        // DEBUG:     sentry_options_t *opts, int val)
        public static void SentryOptionsSetSymbolizeStacktraces(global::Sentry.Native.SentryOptionsS opts, int val)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetSymbolizeStacktraces(__arg0, val);
        }

        /// <summary>Returns true if on-device symbolication of stack traces is enabled.</summary>
        // DEBUG: SENTRY_API int sentry_options_get_symbolize_stacktraces(
        // DEBUG:     const sentry_options_t *opts)
        public static int SentryOptionsGetSymbolizeStacktraces(global::Sentry.Native.SentryOptionsS opts)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            var __ret = __Internal.SentryOptionsGetSymbolizeStacktraces(__arg0);
            return __ret;
        }

        /// <summary>Adds a new attachment to be sent along.</summary>
        /// <remarks>
        /// <para>`path` is assumed to be in platform-specific filesystem path encoding.</para>
        /// <para>API Users on windows are encouraged to use `sentry_options_add_attachmentw`</para>
        /// <para>instead.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_options_add_attachment(
        // DEBUG:     sentry_options_t *opts, const char *path)
        public static void SentryOptionsAddAttachment(global::Sentry.Native.SentryOptionsS opts, string path)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsAddAttachment(__arg0, path);
        }

        /// <summary>Sets the path to the crashpad handler if the crashpad backend is used.</summary>
        /// <remarks>
        /// <para>The path defaults to the `crashpad_handler`/`crashpad_handler.exe`</para>
        /// <para>executable, depending on platform, which is expected to be present in the</para>
        /// <para>same directory as the app executable.</para>
        /// <para>It is recommended that library users set an explicit handler path, depending</para>
        /// <para>on the directory/executable structure of their app.</para>
        /// <para>`path` is assumed to be in platform-specific filesystem path encoding.</para>
        /// <para>API Users on windows are encouraged to use `sentry_options_set_handler_pathw`</para>
        /// <para>instead.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_options_set_handler_path(
        // DEBUG:     sentry_options_t *opts, const char *path)
        public static void SentryOptionsSetHandlerPath(global::Sentry.Native.SentryOptionsS opts, string path)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetHandlerPath(__arg0, path);
        }

        /// <summary>Sets the path to the Sentry Database Directory.</summary>
        /// <remarks>
        /// <para>Sentry will use this path to persist user consent, sessions, and other</para>
        /// <para>artifacts in case of a crash. This will also be used by the crashpad backend</para>
        /// <para>if it is configured.</para>
        /// <para>The directory is used for &quot;cached&quot; data, which needs to persist across</para>
        /// <para>application restarts to ensure proper flagging of release-health sessions,</para>
        /// <para>but might otherwise be safely purged regularly.</para>
        /// <para>It is roughly equivalent to the type of `AppData/Local` on Windows and</para>
        /// <para>`XDG_CACHE_HOME` on Linux, and equivalent runtime directories on other</para>
        /// <para>platforms.</para>
        /// <para>It is recommended that users set an explicit absolute path, depending</para>
        /// <para>on their apps runtime directory. The path will be created if it does not</para>
        /// <para>exist, and will be resolved to an absolute path inside of `sentry_init`. The</para>
        /// <para>directory should not be shared with other application data/configuration, as</para>
        /// <para>sentry-native will enumerate and possibly delete files in that directory. An</para>
        /// <para>example might be `$XDG_CACHE_HOME/your-app/sentry`</para>
        /// <para>If no explicit path it set, sentry-native will default to `.sentry-native` in</para>
        /// <para>the current working directory, with no specific platform-specific handling.</para>
        /// <para>`path` is assumed to be in platform-specific filesystem path encoding.</para>
        /// <para>API Users on windows are encouraged to use</para>
        /// <para>`sentry_options_set_database_pathw` instead.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_options_set_database_path(
        // DEBUG:     sentry_options_t *opts, const char *path)
        public static void SentryOptionsSetDatabasePath(global::Sentry.Native.SentryOptionsS opts, string path)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetDatabasePath(__arg0, path);
        }

        /// <summary>Enables forwarding to the system crash reporter. Disabled by default.</summary>
        /// <remarks>
        /// <para>This setting only has an effect when using Crashpad on macOS. If enabled,</para>
        /// <para>Crashpad forwards crashes to the macOS system crash reporter. Depending</para>
        /// <para>on the crash, this may impact the crash time. Even if enabled, Crashpad</para>
        /// <para>may choose not to forward certain crashes.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_options_set_system_crash_reporter_enabled(
        // DEBUG:     sentry_options_t *opts, int enabled)
        public static void SentryOptionsSetSystemCrashReporterEnabled(global::Sentry.Native.SentryOptionsS opts, int enabled)
        {
            var __arg0 = opts is null ? __IntPtr.Zero : opts.__Instance;
            __Internal.SentryOptionsSetSystemCrashReporterEnabled(__arg0, enabled);
        }

        /// <summary>Initializes the Sentry SDK with the specified options.</summary>
        /// <remarks>
        /// <para>This takes ownership of the options.  After the options have been set</para>
        /// <para>they cannot be modified any more.</para>
        /// <para>Depending on the configured transport and backend, this function might not be</para>
        /// <para>fully thread-safe.</para>
        /// <para>Returns 0 on success.</para>
        /// </remarks>
        // DEBUG: SENTRY_API int sentry_init(sentry_options_t *options)
        public static int SentryInit(global::Sentry.Native.SentryOptionsS options)
        {
            var __arg0 = options is null ? __IntPtr.Zero : options.__Instance;
            var __ret = __Internal.SentryInit(__arg0);
            return __ret;
        }

        /// <summary>Shuts down the sentry client and forces transports to flush out.</summary>
        /// <remarks>Returns 0 on success.</remarks>
        // DEBUG: SENTRY_API int sentry_shutdown(void)
        public static int SentryShutdown()
        {
            var __ret = __Internal.SentryShutdown();
            return __ret;
        }

        /// <summary>This will lazily load and cache a list of all the loaded libraries.</summary>
        /// <remarks>
        /// <para>Returns a new reference to an immutable, frozen list.</para>
        /// <para>The reference must be released with `sentry_value_decref`.</para>
        /// </remarks>
        // DEBUG: SENTRY_EXPERIMENTAL_API sentry_value_t sentry_get_modules_list(void)
        public static global::Sentry.Native.SentryValueU SentryGetModulesList()
        {
            var __ret = __Internal.SentryGetModulesList();
            return global::Sentry.Native.SentryValueU.__CreateInstance(__ret);
        }

        /// <summary>Clears the internal module cache.</summary>
        /// <remarks>
        /// <para>For performance reasons, sentry will cache the list of loaded libraries when</para>
        /// <para>capturing events. This cache can get out-of-date when loading or unloading</para>
        /// <para>libraries at runtime. It is therefore recommended to call</para>
        /// <para>`sentry_clear_modulecache` when doing so, to make sure that the next call to</para>
        /// <para>`sentry_capture_event` will have an up-to-date module list.</para>
        /// </remarks>
        // DEBUG: SENTRY_EXPERIMENTAL_API void sentry_clear_modulecache(void)
        public static void SentryClearModulecache()
        {
            __Internal.SentryClearModulecache();
        }

        /// <summary>Gives user consent.</summary>
        // DEBUG: SENTRY_API void sentry_user_consent_give(void)
        public static void SentryUserConsentGive()
        {
            __Internal.SentryUserConsentGive();
        }

        /// <summary>Revokes user consent.</summary>
        // DEBUG: SENTRY_API void sentry_user_consent_revoke(void)
        public static void SentryUserConsentRevoke()
        {
            __Internal.SentryUserConsentRevoke();
        }

        /// <summary>Resets the user consent (back to unknown).</summary>
        // DEBUG: SENTRY_API void sentry_user_consent_reset(void)
        public static void SentryUserConsentReset()
        {
            __Internal.SentryUserConsentReset();
        }

        /// <summary>Checks the current state of user consent.</summary>
        // DEBUG: SENTRY_API sentry_user_consent_t sentry_user_consent_get(void)
        public static global::Sentry.Native.SentryUserConsentT SentryUserConsentGet()
        {
            var __ret = __Internal.SentryUserConsentGet();
            return __ret;
        }

        /// <summary>Sends a sentry event.</summary>
        // DEBUG: SENTRY_API sentry_uuid_t sentry_capture_event(sentry_value_t event)
        public static global::Sentry.Native.SentryUuidS SentryCaptureEvent(global::Sentry.Native.SentryValueU @event)
        {
            var __arg0 = @event.__Instance;
            var __ret = __Internal.SentryCaptureEvent(__arg0);
            return global::Sentry.Native.SentryUuidS.__CreateInstance(__ret);
        }

        /// <summary>Captures an exception to be handled by the backend.</summary>
        /// <remarks>This is safe to be called from a crashing thread and may not return.</remarks>
        // DEBUG: SENTRY_EXPERIMENTAL_API void sentry_handle_exception(
        // DEBUG:     const sentry_ucontext_t *uctx)
        public static void SentryHandleException(global::Sentry.Native.SentryUcontextS uctx)
        {
            var __arg0 = uctx is null ? __IntPtr.Zero : uctx.__Instance;
            __Internal.SentryHandleException(__arg0);
        }

        /// <summary>Adds the breadcrumb to be sent in case of an event.</summary>
        // DEBUG: SENTRY_API void sentry_add_breadcrumb(sentry_value_t breadcrumb)
        public static void SentryAddBreadcrumb(global::Sentry.Native.SentryValueU breadcrumb)
        {
            var __arg0 = breadcrumb.__Instance;
            __Internal.SentryAddBreadcrumb(__arg0);
        }

        /// <summary>Sets the specified user.</summary>
        // DEBUG: SENTRY_API void sentry_set_user(sentry_value_t user)
        public static void SentrySetUser(global::Sentry.Native.SentryValueU user)
        {
            var __arg0 = user.__Instance;
            __Internal.SentrySetUser(__arg0);
        }

        /// <summary>Removes a user.</summary>
        // DEBUG: SENTRY_API void sentry_remove_user(void)
        public static void SentryRemoveUser()
        {
            __Internal.SentryRemoveUser();
        }

        /// <summary>Sets a tag.</summary>
        // DEBUG: SENTRY_API void sentry_set_tag(const char *key, const char *value)
        public static void SentrySetTag(string key, string value)
        {
            __Internal.SentrySetTag(key, value);
        }

        /// <summary>Removes the tag with the specified key.</summary>
        // DEBUG: SENTRY_API void sentry_remove_tag(const char *key)
        public static void SentryRemoveTag(string key)
        {
            __Internal.SentryRemoveTag(key);
        }

        /// <summary>Sets extra information.</summary>
        // DEBUG: SENTRY_API void sentry_set_extra(const char *key, sentry_value_t value)
        public static void SentrySetExtra(string key, global::Sentry.Native.SentryValueU value)
        {
            var __arg1 = value.__Instance;
            __Internal.SentrySetExtra(key, __arg1);
        }

        /// <summary>Removes the extra with the specified key.</summary>
        // DEBUG: SENTRY_API void sentry_remove_extra(const char *key)
        public static void SentryRemoveExtra(string key)
        {
            __Internal.SentryRemoveExtra(key);
        }

        /// <summary>Sets a context object.</summary>
        // DEBUG: SENTRY_API void sentry_set_context(const char *key, sentry_value_t value)
        public static void SentrySetContext(string key, global::Sentry.Native.SentryValueU value)
        {
            var __arg1 = value.__Instance;
            __Internal.SentrySetContext(key, __arg1);
        }

        /// <summary>Removes the context object with the specified key.</summary>
        // DEBUG: SENTRY_API void sentry_remove_context(const char *key)
        public static void SentryRemoveContext(string key)
        {
            __Internal.SentryRemoveContext(key);
        }

        /// <summary>Sets the event fingerprint.</summary>
        /// <remarks>
        /// <para>This accepts a variable number of arguments, and needs to be terminated by a</para>
        /// <para>trailing `NULL`.</para>
        /// </remarks>
        // DEBUG: SENTRY_API void sentry_set_fingerprint(const char *fingerprint, ...)
        public static void SentrySetFingerprint(string fingerprint)
        {
            __Internal.SentrySetFingerprint(fingerprint);
        }

        /// <summary>Removes the fingerprint.</summary>
        // DEBUG: SENTRY_API void sentry_remove_fingerprint(void)
        public static void SentryRemoveFingerprint()
        {
            __Internal.SentryRemoveFingerprint();
        }

        /// <summary>Sets the transaction.</summary>
        // DEBUG: SENTRY_API void sentry_set_transaction(const char *transaction)
        public static void SentrySetTransaction(string transaction)
        {
            __Internal.SentrySetTransaction(transaction);
        }

        /// <summary>Removes the transaction.</summary>
        // DEBUG: SENTRY_API void sentry_remove_transaction(void)
        public static void SentryRemoveTransaction()
        {
            __Internal.SentryRemoveTransaction();
        }

        /// <summary>Sets the event level.</summary>
        // DEBUG: SENTRY_API void sentry_set_level(sentry_level_t level)
        public static void SentrySetLevel(global::Sentry.Native.SentryLevelE level)
        {
            __Internal.SentrySetLevel(level);
        }

        /// <summary>Starts a new session.</summary>
        // DEBUG: SENTRY_API void sentry_start_session(void)
        public static void SentryStartSession()
        {
            __Internal.SentryStartSession();
        }

        /// <summary>Ends a session.</summary>
        // DEBUG: SENTRY_API void sentry_end_session(void)
        public static void SentryEndSession()
        {
            __Internal.SentryEndSession();
        }

        // DEBUG: extern __const char *__const sys_signame[NSIG]
        public static string[] SysSigname
        {
            get
            {
                var __ptr = (__IntPtr*)global::Sentry.Native.__Symbols.SentryNative._sys_signame;
                string[] __value = null;
                if (__ptr != null)
                {
                    __value = new string[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = __ptr[i];
                }
                return __value;
            }
        }

        // DEBUG: extern __const char *__const sys_siglist[NSIG]
        public static string[] SysSiglist
        {
            get
            {
                var __ptr = (__IntPtr*)global::Sentry.Native.__Symbols.SentryNative._sys_siglist;
                string[] __value = null;
                if (__ptr != null)
                {
                    __value = new string[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = __ptr[i];
                }
                return __value;
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_Sentry_Native_sigval___Internal(global::Sentry.Native.Sigval.__Internal __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int(int __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int___IntPtr___IntPtr(int __0, __IntPtr __1, __IntPtr __2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int_int___IntPtr___IntPtr(__IntPtr __0, int __1, int __2, __IntPtr __3, __IntPtr __4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr envelope, __IntPtr state);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr(__IntPtr options, __IntPtr state);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_ulong___IntPtr(ulong timeout, __IntPtr state);
    }
}
namespace Sentry.Native.__Symbols
{
    internal class SentryNative
    {
        public static IntPtr _sys_signame { get; }
        public static IntPtr _sys_siglist { get; }
        static SentryNative()
        {
            var path = "SentryNative";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new System.DllNotFoundException(path);
            _sys_signame = CppSharp.SymbolResolver.ResolveSymbol(image, "sys_signame");
            _sys_siglist = CppSharp.SymbolResolver.ResolveSymbol(image, "sys_siglist");
        }
    }
}

